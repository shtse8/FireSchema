# Advanced Usage

This section explores more complex scenarios and patterns when using the code generated by FireSchema.

## Working with Subcollections

FireSchema generates convenient accessors for subcollections defined in your schema, allowing you to navigate and interact with nested data structures in a type-safe manner.

Let's assume a schema where `users` have a `posts` subcollection, and `posts` have a `comments` subcollection:

```json
// firestore.schema.json (simplified)
{
  "collections": {
    "users": {
      "fields": { /* ... user fields ... */ },
      "subcollections": {
        "posts": {
          "fields": {
            "title": { "type": "string" },
            "content": { "type": "string" }
          },
          "subcollections": {
            "comments": {
              "fields": {
                "authorName": { "type": "string" },
                "text": { "type": "string" }
              }
            }
          }
        }
      }
    }
  }
}
```

### Accessing Subcollections

The generated parent collection class (e.g., `UsersCollection`) will have methods corresponding to the defined subcollections (e.g., `posts`). These methods take the parent document ID as an argument and return a typed collection reference for the subcollection.

**TypeScript Example:**

```typescript
import { firestore } from "./firebase-init"; // Assume initialized Firestore instance
import { UsersCollection } from "../generated/ts-client/users.collection";
// Generated subcollection classes are often in nested directories or named accordingly
import { PostsCollection } from "../generated/ts-client/users/posts.collection";
import { CommentsCollection } from "../generated/ts-client/users/posts/comments.collection";
import { PostAddData } from "../generated/ts-client/users/posts.types";
import { CommentAddData } from "../generated/ts-client/users/posts/comments.types";

const usersCollection = new UsersCollection(firestore);
const userId = "some-user-id";

// Get a reference to the 'posts' subcollection for a specific user
const userPostsCollection: PostsCollection = usersCollection.posts(userId);

// Now you can use userPostsCollection like any other collection reference
async function addPost() {
  const newPost: PostAddData = { title: "My Post", content: "..." };
  const postRef = await userPostsCollection.add(newPost);
  console.log("Added post:", postRef.id);
  return postRef.id;
}

// Accessing a 2nd-level subcollection ('comments' under 'posts')
async function addComment(postId: string) {
  // Get the posts collection first, then the comments subcollection
  const postCommentsCollection: CommentsCollection = userPostsCollection.comments(postId);
  // Or chain directly: usersCollection.posts(userId).comments(postId)

  const newComment: CommentAddData = { authorName: "Jane", text: "Great post!" };
  const commentRef = await postCommentsCollection.add(newComment);
  console.log("Added comment:", commentRef.id);

  // Query comments for that specific post
  const comments = await postCommentsCollection.query().getData();
  console.log(`Comments for post ${postId}:`, comments.length);
}

addPost().then(postId => addComment(postId));
```

**Dart Example:**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
// Assume firestore instance is initialized
// final firestore = FirebaseFirestore.instance;

// Import generated files
import 'generated/firestore_dart/users_collection.dart';
import 'generated/firestore_dart/users/posts_collection.dart';
import 'generated/firestore_dart/users/posts_data.dart';
import 'generated/firestore_dart/users/posts/comments_collection.dart';
import 'generated/firestore_dart/users/posts/comments_data.dart';

void main() async {
  final firestore = FirebaseFirestore.instance; // Example initialization
  final usersCollection = UsersCollection(firestore: firestore);
  final userId = 'some-user-id';

  // Get reference to 'posts' subcollection
  final userPostsCollection = usersCollection.posts(userId);

  // Add a post
  final newPost = PostsAddData(title: 'My Dart Post', content: '...');
  final postRef = await userPostsCollection.add(newPost);
  print('Added post: ${postRef.id}');
  final postId = postRef.id;

  // Get reference to 'comments' subcollection under the new post
  final postCommentsCollection = userPostsCollection.comments(postId);
  // Or chain: usersCollection.posts(userId).comments(postId);

  // Add a comment
  final newComment = CommentsAddData(authorName: 'Peter', text: 'Nice!');
  final commentRef = await postCommentsCollection.add(newComment);
  print('Added comment: ${commentRef.id}');

  // Query comments for the post
  final comments = await postCommentsCollection.query().getData();
  print('Comments for post $postId: ${comments.length}');
}
```

### Key Points

-   The generated accessor method (e.g., `posts(userId)`) takes the **ID** of the immediate parent document.
-   The returned object is a fully typed collection reference for the subcollection, allowing you to perform `add`, `get`, `update`, `delete`, and `query` operations just like on a top-level collection.
-   This pattern extends naturally to multiple levels of nesting.

## Handling `DocumentReference` Fields

When your schema defines a field with `type: "reference"`, FireSchema generates a field typed as `DocumentReference` (or `DocumentReference<ReferencedTypeData>` in TypeScript if `referenceTo` is provided).

Storing a reference is straightforward using the `UpdateBuilder` or during document creation:

```typescript
// Assume 'users' have 'primaryOrderRef' field referencing 'orders' collection
import { OrdersCollection } from "../generated/ts-client/orders.collection";
import { OrderAddData } from "../generated/ts-client/orders.types";

const ordersCollection = new OrdersCollection(firestore);
const newOrder: OrderAddData = { /* ... order details ... */ };
const orderRef = await ordersCollection.add(newOrder);

// Set the reference on the user document
await usersCollection.update(userId)
  .setPrimaryOrderRef(orderRef) // Pass the DocumentReference directly
  .commit();
```

The more interesting part is fetching the data pointed to by the reference. The `DocumentReference` itself only contains the *path* to the referenced document, not its data. You need to perform a separate fetch operation.

**TypeScript Example (using generated types):**

```typescript
import { UserData } from "../generated/ts-client/users.types";
import { OrderData } from "../generated/ts-client/orders.types"; // Import referenced type

async function getUserAndPrimaryOrder(userId: string): Promise<{ user: UserData; order: OrderData | null } | null> {
  const userData = await usersCollection.get(userId);

  if (!userData || !userData.primaryOrderRef) {
    console.log("User not found or has no primary order reference.");
    return null;
  }

  console.log("User primary order path:", userData.primaryOrderRef.path);

  // userData.primaryOrderRef is DocumentReference<OrderData> because 'referenceTo' was set

  // Fetch the referenced document using its specific collection helper or directly
  // Option 1: Use the specific collection helper (recommended for type safety)
  const orderData = await ordersCollection.get(userData.primaryOrderRef.id);

  // Option 2: Use the reference directly (less type-safe if helper isn't available)
  // import { getDoc } from 'firebase/firestore';
  // const orderSnap = await getDoc(userData.primaryOrderRef);
  // const orderData = orderSnap.exists() ? ordersCollection.converter.fromFirestore(orderSnap) : null;

  if (orderData) {
    console.log("Fetched primary order details:", orderData); // Access order fields safely
  } else {
    console.log("Primary order document not found (reference might be stale).");
  }

  return { user: userData, order: orderData };
}
```

**Dart Example:**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'generated/firestore_dart/users_collection.dart';
import 'generated/firestore_dart/users_data.dart';
import 'generated/firestore_dart/orders_collection.dart'; // Import referenced collection
import 'generated/firestore_dart/orders_data.dart';     // Import referenced data class

Future<void> getUserAndPrimaryOrder(String userId) async {
  final userData = await usersCollection.get(userId);

  if (userData == null || userData.primaryOrderRef == null) {
    print('User not found or no primary order ref.');
    return;
  }

  // userData.primaryOrderRef is DocumentReference<Map<String, dynamic>> in Dart currently
  print('User primary order path: ${userData.primaryOrderRef!.path}');

  // Fetch the referenced document
  // Option 1: Use the specific collection helper (recommended)
  final ordersCollection = OrdersCollection(firestore: firestore);
  final orderData = await ordersCollection.get(userData.primaryOrderRef!.id);

  // Option 2: Use the reference directly and manually convert
  // final orderSnap = await userData.primaryOrderRef!.get();
  // final orderData = orderSnap.exists
  //     ? OrdersData.fromSnapshot(orderSnap) // Use generated fromSnapshot
  //     : null;

  if (orderData != null) {
    print('Fetched primary order details: ${orderData}'); // Access order fields
  } else {
    print('Primary order document not found.');
  }
}
```

### Key Points for References:

-   **Separate Fetches:** Retrieving referenced data always requires an additional `get()` call. Firestore doesn't automatically "join" documents.
-   **Type Safety (TypeScript):** If you provide the `referenceTo` property in your schema (e.g., `"referenceTo": "orders"`), the generated TypeScript `DocumentReference` will be strongly typed (e.g., `DocumentReference<OrderData>`), making direct fetching with `getDoc` slightly less safe than using the specific generated collection helper (`ordersCollection.get(...)`).
-   **Type Safety (Dart):** Currently, the generated Dart `DocumentReference` is `DocumentReference<Map<String, dynamic>>`. You need to use the specific collection helper (`ordersCollection.get(...)`) or manually fetch and use the generated `fromSnapshot` constructor (e.g., `OrdersData.fromSnapshot(snapshot)`) to get a typed object.
-   **Stale References:** The referenced document might be deleted. Always check if the fetched data is `null`.

## Advanced Querying Techniques

The generated `QueryBuilder` provides type-safe methods for common Firestore query operators. Here's how to use some of the more advanced ones:

### Pagination (Cursors)

The runtime `BaseQueryBuilder` provides methods like `startAt`, `startAfter`, `endAt`, `endBefore`, which accept either a `DocumentSnapshot` or field values corresponding to your `orderBy` clause.

**TypeScript Example:**

```typescript
import { DocumentSnapshot } from "firebase/firestore"; // Or admin SDK equivalent

let lastVisible: DocumentSnapshot | null = null;

async function getNextPageOfUsers() {
  let query = usersCollection.query()
    .orderBy("displayName")
    .limit(10);

  if (lastVisible) {
    query = query.startAfter(lastVisible); // Pass the snapshot from the previous query
  }

  const snapshot = await query.get(); // Use get() to get the QuerySnapshot

  if (!snapshot.empty) {
    lastVisible = snapshot.docs[snapshot.docs.length - 1]; // Store the last doc for the next page
  } else {
    lastVisible = null; // No more documents
  }

  const users = usersCollection.converter.fromFirestoreQuerySnapshot(snapshot); // Convert snapshot to data array
  console.log(`Fetched ${users.length} users.`);
  users.forEach(u => console.log('-', u.displayName));
}

// Call getNextPageOfUsers() multiple times to paginate
```

**Dart Example:**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

DocumentSnapshot? lastVisible;

Future<void> getNextPageOfUsers() async {
  var query = usersCollection.query()
      .orderBy('displayName')
      .limit(10);

  if (lastVisible != null) {
    query = query.startAfterDocument(lastVisible!); // Pass the snapshot
  }

  final snapshot = await query.get(); // Use get() from runtime

  if (snapshot.docs.isNotEmpty) {
    lastVisible = snapshot.docs.last;
  } else {
    lastVisible = null;
  }

  // getData() can also be used, but get() gives access to the snapshot for pagination
  final users = snapshot.docs.map((doc) => UsersData.fromSnapshot(doc)).toList();
  print('Fetched ${users.length} users.');
  users.forEach((u) => print('- ${u.displayName}'));
}

// Call getNextPageOfUsers() multiple times
```

### `whereIn`, `whereNotIn`, `array-contains-any`

Firestore allows querying based on multiple values for a field (`in`, `not-in`) or checking if an array field contains any of multiple values (`array-contains-any`). FireSchema generates corresponding type-safe methods on the `QueryBuilder`.

**TypeScript Example:**

```typescript
// Assume 'status' field and 'tags' array field on users

// Find users with specific statuses
const pendingOrProcessingUsers = await usersCollection.query()
  .whereStatus("in", ["pending", "processing"]) // Generated method
  .getData();

// Find users NOT with specific statuses
const completedOrFailedUsers = await usersCollection.query()
  .whereStatus("not-in", ["pending", "processing"]) // Generated method
  .getData();

// Find users with either 'beta' or 'vip' tag
const betaOrVipUsers = await usersCollection.query()
  .whereTags("array-contains-any", ["beta", "vip"]) // Generated method
  .getData();
```

**Dart Example:**

```dart
// Assume 'status' field and 'tags' array field on users

// Find users with specific statuses
final pendingOrProcessingUsers = await usersCollection.query()
    .whereStatus(whereIn: ['pending', 'processing']) // Generated method
    .getData();

// Find users NOT with specific statuses
final completedOrFailedUsers = await usersCollection.query()
    .whereStatus(whereNotIn: ['pending', 'processing']) // Generated method
    .getData();

// Find users with either 'beta' or 'vip' tag
final betaOrVipUsers = await usersCollection.query()
    .whereTags(arrayContainsAny: ['beta', 'vip']) // Generated method
    .getData();
```

**Note:** Firestore limits the number of values in `in`, `not-in`, and `array-contains-any` queries (typically 10, but check Firestore documentation for current limits).

## Using `UpdateBuilder` for Complex Atomic Updates

The generated `UpdateBuilder` (e.g., `UsersUpdateBuilder`) provides type-safe methods for setting fields (`setFieldName(value)`), incrementing numbers (`incrementFieldName(value)`), and setting server timestamps (`setFieldNameToServerTimestamp()`).

For more complex atomic operations like updating nested fields or using `FieldValue` operations (`arrayUnion`, `arrayRemove`, `delete`), you can use the underlying `updateRaw(data)` method provided by the runtime `BaseUpdateBuilder`.

### Updating Nested Fields

To update a specific field within a map (object), use dot notation in the key passed to `updateRaw`.

**TypeScript Example:**

```typescript
// Assume user has a 'settings' object field: { theme: string, notificationsEnabled: boolean }
import { serverTimestamp, FieldValue } from "firebase/firestore"; // Or admin SDK

await usersCollection.update(userId)
  .setLastLogin(serverTimestamp()) // Use generated method for top-level field
  .updateRaw({ // Use updateRaw for nested fields or FieldValue
    'settings.theme': 'dark', // Update only the theme using dot notation
    'profile.visits': FieldValue.increment(1) // Assuming profile.visits exists
  })
  .commit();
```

**Dart Example:**

```dart
// Assume user has a 'settings' object field: { theme: string, notificationsEnabled: boolean }
import 'package:cloud_firestore/cloud_firestore.dart';

await usersCollection.update(userId)
  .setLastLoginToServerTimestamp() // Use generated method
  .updateRaw({ // Use updateRaw for nested fields or FieldValue
    'settings.theme': 'dark', // Update only the theme using dot notation
    'profile.visits': FieldValue.increment(1), // Assuming profile.visits exists
  })
  .commit();
```

### Using `FieldValue` Operations

Pass `FieldValue` constants directly within the `updateRaw` map for atomic array modifications or field deletions.

**TypeScript Example:**

```typescript
import { arrayUnion, arrayRemove, deleteField } from "firebase/firestore"; // Or admin SDK

await usersCollection.update(userId)
  .updateRaw({
    tags: arrayUnion('new-tag', 'another-tag'), // Add elements to array
    // tags: arrayRemove('old-tag'), // Remove elements from array
    // oldField: deleteField(), // Delete a field entirely
  })
  .commit();
```

**Dart Example:**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

await usersCollection.update(userId)
  .updateRaw({
    'tags': FieldValue.arrayUnion(['new-tag', 'another-tag']), // Add elements
    // 'tags': FieldValue.arrayRemove(['old-tag']), // Remove elements
    // 'oldField': FieldValue.delete(), // Delete a field
  })
  .commit();
```

### Combining Generated Methods and `updateRaw`

You can chain generated methods and `updateRaw` calls within a single `update()` operation before calling `commit()`. The runtime merges these operations into a single underlying Firestore update call.

## Integrating with State Management Libraries

The generated ODM classes work well with popular state management solutions. The key is usually to provide the generated collection reference (e.g., `UsersCollection`) to your state management logic (repositories, providers, stores).

**Dart (Riverpod Example):**

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'generated/firestore_dart/users_collection.dart';
import 'generated/firestore_dart/users_data.dart';

// 1. Provider for the Firestore instance
final firestoreProvider = Provider((ref) => FirebaseFirestore.instance);

// 2. Provider for the generated UsersCollection
final usersCollectionProvider = Provider((ref) {
  final firestore = ref.watch(firestoreProvider);
  return UsersCollection(firestore: firestore);
});

// 3. Provider to fetch a single user (using .get)
final userProvider = FutureProvider.family<UserData?, String>((ref, userId) {
  final usersCollection = ref.watch(usersCollectionProvider);
  return usersCollection.get(userId);
});

// 4. Provider to stream a list of users (using .snapshots())
final activeUsersStreamProvider = StreamProvider<List<UserData>>((ref) {
  final usersCollection = ref.watch(usersCollectionProvider);
  // Access the underlying snapshots stream via the runtime
  return usersCollection.query()
      .whereIsActive(isEqualTo: true)
      .orderBy('displayName')
      .snapshots() // Access snapshots() from the runtime base class
      .map((snapshot) => usersCollection.converter.fromFirestoreQuerySnapshot(snapshot)); // Use converter
});

// In your Widget:
Consumer(
  builder: (context, ref, child) {
    final asyncUser = ref.watch(userProvider('some-user-id'));
    final asyncActiveUsers = ref.watch(activeUsersStreamProvider);

    return asyncUser.when(
      data: (user) => user == null ? Text('User not found') : Text('User: ${user.displayName}'),
      loading: () => CircularProgressIndicator(),
      error: (err, stack) => Text('Error: $err'),
    );
    // Similarly handle asyncActiveUsers.when(...)
  },
)
```

**TypeScript (Zustand Example - Conceptual):**

```typescript
import { create } from 'zustand';
import { firestore } from './firebase-init';
import { UsersCollection } from '../generated/ts-client/users.collection';
import { UserData } from '../generated/ts-client/users.types';
import { onSnapshot, Unsubscribe } from 'firebase/firestore'; // For real-time updates

interface UserState {
  users: UserData[];
  isLoading: boolean;
  error: Error | null;
  usersCollection: UsersCollection; // Keep instance for actions
  unsubscribe: Unsubscribe | null;
  fetchUsers: () => Promise<void>;
  subscribeToActiveUsers: () => void;
  addUser: (userData: UserAddData) => Promise<void>;
}

const useUserStore = create<UserState>((set, get) => ({
  users: [],
  isLoading: false,
  error: null,
  usersCollection: new UsersCollection(firestore), // Initialize once
  unsubscribe: null,

  fetchUsers: async () => {
    set({ isLoading: true, error: null });
    try {
      const users = await get().usersCollection.query().limit(20).getData();
      set({ users, isLoading: false });
    } catch (error) {
      set({ error: error as Error, isLoading: false });
    }
  },

  subscribeToActiveUsers: () => {
    // Unsubscribe from previous listener if exists
    get().unsubscribe?.();

    const query = get().usersCollection.query()
      .whereIsActive("==", true)
      .orderBy("displayName");

    // Access underlying query via runtime for onSnapshot
    const unsubscribe = onSnapshot(query.query, (snapshot) => { // Access internal query
      const users = get().usersCollection.converter.fromFirestoreQuerySnapshot(snapshot);
      set({ users });
    }, (error) => {
      set({ error });
    });

    set({ unsubscribe }); // Store the unsubscribe function
  },

  addUser: async (userData) => {
    // Potentially set loading state
    try {
      await get().usersCollection.add(userData);
      // Optionally refetch or rely on subscription to update state
    } catch (error) {
      set({ error: error as Error });
    }
  },
}));

// In your React component:
// const { users, isLoading, fetchUsers, subscribeToActiveUsers } = useUserStore();
// useEffect(() => { subscribeToActiveUsers(); return () => useUserStore.getState().unsubscribe?.(); }, []);
```

The key is that the generated collection classes encapsulate the Firestore interaction logic, making them easy to inject or use within your state management patterns. You might need to access the underlying `query` or `ref` properties from the runtime base classes for direct integration with stream/snapshot listeners provided by the Firebase SDKs.

## Transactions and Batched Writes

Firestore's transactions and batched writes allow you to perform multiple operations atomically. While the generated `Collection` classes don't directly expose transaction/batch methods, you can easily use them with the underlying Firestore SDK functions, leveraging the generated types and converters.

The core idea is to get the raw `DocumentReference` from the generated collection helper and use the standard SDK transaction/batch methods (`transaction.get`, `transaction.set`, `transaction.update`, `batch.set`, `batch.update`, `batch.delete`). You'll use the generated `converter` to handle data serialization.

**TypeScript Example (Transaction):**

```typescript
import { runTransaction, doc, Transaction } from "firebase/firestore";
import { UserData, UserAddData } from "../generated/ts-client/users.types";
import { StatsCollection } from "../generated/ts-client/stats.collection"; // Assume a stats collection

const statsCollection = new StatsCollection(firestore);

async function addUserAndUpdateStats(newUser: UserAddData): Promise<void> {
  await runTransaction(firestore, async (transaction: Transaction) => {
    // 1. Get a raw reference for the new user document
    const newUserRef = doc(usersCollection.ref); // Get raw CollectionReference from runtime

    // 2. Get a raw reference for the stats document
    const statsDocRef = doc(statsCollection.ref, 'userStats'); // Get raw ref and specify doc ID

    // 3. Read the current stats within the transaction
    const statsSnap = await transaction.get(statsDocRef);
    // Manually convert using the converter if needed, or handle non-existence
    const currentCount = statsSnap.exists() ? statsSnap.data()?.userCount ?? 0 : 0;

    // 4. Set the new user data using the transaction and converter
    // Note: transaction.set requires the raw DocumentReference
    transaction.set(newUserRef, newUser, { merge: false }); // Use generated AddData type

    // 5. Update the stats using the transaction
    transaction.update(statsDocRef, { userCount: currentCount + 1 });
  });
  console.log("Transaction successful: Added user and updated stats.");
}
```

**Dart Example (Batched Write):**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'generated/firestore_dart/users_collection.dart';
import 'generated/firestore_dart/users_data.dart';
import 'generated/firestore_dart/logs_collection.dart'; // Assume a logs collection
import 'generated/firestore_dart/logs_data.dart';

Future<void> deleteUserAndAddLog(String userIdToDelete) async {
  final batch = firestore.batch();

  // 1. Get raw references
  final userDocRef = usersCollection.docRef(userIdToDelete); // Use runtime helper for raw DocumentReference
  final logsCollection = LogsCollection(firestore: firestore);
  final logDocRef = logsCollection.docRef(); // Get ref for new log doc

  // 2. Add operations to the batch
  batch.delete(userDocRef);

  final logEntry = LogsAddData(
    message: 'Deleted user $userIdToDelete',
    timestamp: Timestamp.now(), // Or use serverTimestamp via FieldValue
  );
  // Use the converter for setting data in batch/transaction
  batch.set(logDocRef, logsCollection.converter.toFirestore(logEntry));

  // 3. Commit the batch
  await batch.commit();
  print('Batch successful: Deleted user and added log entry.');
}
```

### Key Points for Transactions/Batches:

-   **Use Raw References:** Obtain the raw `DocumentReference` or `CollectionReference` from the generated helpers (e.g., `usersCollection.ref`, `usersCollection.docRef(id)`).
-   **Use SDK Functions:** Call the standard Firestore SDK functions (`runTransaction`, `writeBatch`, `transaction.get`, `batch.set`, etc.).
-   **Leverage Converters:** When setting or updating data within a transaction or batch, use the generated `converter` (`usersCollection.converter.toFirestore(data)`) to ensure data is correctly serialized, especially for custom types like Timestamps or generated Enums. When reading with `transaction.get`, you might need `converter.fromFirestore(snapshot)` if you need the typed object within the transaction callback.

## Error Handling Strategies

When interacting with Firestore using the generated code, errors can occur due to various reasons like network issues, permission denied (Security Rules), invalid data, or transaction conflicts. FireSchema itself doesn't introduce new error types; you'll primarily deal with standard `FirebaseError` (TypeScript) or `FirebaseException` (Dart).

**General Approach:**

Use standard `try...catch` blocks (or `.catchError` with Futures/Streams in Dart) around your Firestore operations. Inspect the caught error object to determine the cause.

**TypeScript Example:**

```typescript
import { FirebaseError } from "firebase/app"; // Or from 'firebase-admin'

async function safeGetUser(userId: string): Promise<UserData | null> {
  try {
    const user = await usersCollection.get(userId);
    if (!user) {
      console.log(`User ${userId} not found.`);
      return null;
    }
    return user;
  } catch (error) {
    if (error instanceof FirebaseError) {
      console.error(`Firestore Error (${error.code}): ${error.message}`);
      // Handle specific codes
      if (error.code === 'permission-denied') {
        // Show appropriate message to user
      } else if (error.code === 'unavailable') {
        // Suggest retrying later
      }
      // ... other specific codes: 'not-found', 'invalid-argument', etc.
    } else {
      console.error("An unexpected error occurred:", error);
    }
    return null; // Or rethrow, or return a specific error state
  }
}
```

**Dart Example:**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

Future<UserData?> safeGetUser(String userId) async {
  try {
    final user = await usersCollection.get(userId);
    if (user == null) {
      print('User $userId not found.');
      return null;
    }
    return user;
  } on FirebaseException catch (e) {
    print('Firestore Error (${e.code}): ${e.message}');
    // Handle specific codes
    if (e.code == 'permission-denied') {
      // Show message
    } else if (e.code == 'unavailable') {
      // Suggest retry
    }
    // ... other codes
    return null; // Or rethrow, or return specific error state
  } catch (e) {
    print('An unexpected error occurred: $e');
    return null;
  }
}

// Handling errors in Streams (e.g., with Riverpod)
// The StreamProvider handles errors via the AsyncValue.error state.
// You can display the error in the UI:
// asyncActiveUsers.when(
//   ...
//   error: (err, stack) => Text('Error loading users: $err'),
// )
```

### Common Error Codes to Handle:

-   `permission-denied`: User does not have access according to Firestore Security Rules.
-   `unavailable`: Temporary network issue or backend unavailability. Often worth retrying.
-   `not-found`: Document referenced in a `get` or `update` does not exist.
-   `invalid-argument`: Data being written doesn't match expected types (less common with FireSchema's type safety, but possible with `updateRaw` or incorrect `FieldValue` usage).
-   `aborted`: Transaction conflict; Firestore automatically retries transactions a few times, but if it fails repeatedly, this error is thrown.
-   `unauthenticated`: User is not logged in.

Always refer to the official Firebase documentation for a complete list of error codes for Firestore. Robust error handling is crucial for a reliable application.

## Testing Code that Uses the Generated ODM

Testing code that interacts with Firestore, including code using the FireSchema generated ODM, typically involves two main approaches:

1.  **Integration Testing with Emulators:** Running tests against the official Firebase Emulators (specifically the Firestore emulator) provides the highest fidelity, ensuring your code works correctly with real Firestore behavior, including security rules.
2.  **Unit Testing with Mocks/Fakes:** Mocking the Firestore SDK or using fake implementations allows for faster, isolated unit tests without needing the emulator.

### Integration Testing (Recommended for Core Logic)

This is the approach used within the FireSchema runtime packages themselves.

**Setup:**

-   Install the Firebase CLI: `npm install -g firebase-tools`
-   Start the Firestore emulator: `firebase emulators:start --only firestore` (or configure it in `firebase.json`).
-   Configure your test environment to connect to the emulator.

**TypeScript (Jest Example):**

```typescript
import { initializeApp, deleteApp, FirebaseApp } from 'firebase/app';
import { getFirestore, connectFirestoreEmulator, clearFirestoreData, Firestore } from 'firebase/firestore';
import { UsersCollection } from '../generated/ts-client/users.collection'; // Your generated code

let app: FirebaseApp;
let firestore: Firestore;
let usersCollection: UsersCollection;

// Test Firebase config (use a dummy project ID for emulator)
const testProjectId = `test-${Date.now()}`;
const firebaseConfig = { projectId: testProjectId /* ... other dummy config if needed */ };

beforeAll(async () => {
  app = initializeApp(firebaseConfig);
  firestore = getFirestore(app);
  connectFirestoreEmulator(firestore, '127.0.0.1', 8080); // Default emulator port
  usersCollection = new UsersCollection(firestore);
});

beforeEach(async () => {
  // Clear emulator data between tests
  await clearFirestoreData({ projectId: testProjectId });
});

afterAll(async () => {
  await deleteApp(app); // Clean up Firebase app instance
});

// Your tests...
test('should add and get a user', async () => {
  const userId = 'user1';
  const userData = { displayName: 'Test User', email: 'test@example.com' };

  // Use generated methods against the emulator
  await usersCollection.set(userId, userData);
  const fetchedUser = await usersCollection.get(userId);

  expect(fetchedUser).not.toBeNull();
  expect(fetchedUser?.displayName).toBe(userData.displayName);
  expect(fetchedUser?.email).toBe(userData.email);
});

test('should query users', async () => {
  await usersCollection.add({ displayName: 'Alice', email: 'a@e.com', age: 30 });
  await usersCollection.add({ displayName: 'Bob', email: 'b@e.com', age: 40 });

  const usersOver35 = await usersCollection.query().whereAge('>', 35).getData();
  expect(usersOver35).toHaveLength(1);
  expect(usersOver35[0].displayName).toBe('Bob');
});
```

**Dart (using `test` and `cloud_firestore`):**

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart'; // Or 'package:test/test.dart' for pure Dart
import 'generated/firestore_dart/users_collection.dart';
import 'generated/firestore_dart/users_data.dart';

// Assume firebase_options.dart exists for emulator config or configure manually
// import 'firebase_options.dart';

late FirebaseFirestore firestore;
late UsersCollection usersCollection;

void main() {
  setUpAll(() async {
    // Required for Flutter tests, might need different setup for pure Dart
    TestWidgetsFlutterBinding.ensureInitialized();
    // Initialize Firebase - ensure options point to emulator or configure manually
    // await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
    // Use a dummy app instance for testing if needed
    await Firebase.initializeApp(name: 'testApp', options: const FirebaseOptions(/* dummy options */));
    firestore = FirebaseFirestore.instanceFor(app: Firebase.app('testApp'));

    // Connect to emulator
    firestore.useFirestoreEmulator('127.0.0.1', 8080);
    usersCollection = UsersCollection(firestore: firestore);
  });

  // Clear data before each test (Helper function needed)
  Future<void> clearFirestoreData() async {
    // Implement logic to clear collections used in tests, e.g., by querying all docs and deleting
    final users = await usersCollection.query().get();
    final batch = firestore.batch();
    for (final doc in users.docs) {
      batch.delete(doc.reference);
    }
    await batch.commit();
    // Repeat for other collections...
  }

  setUp(() async {
    await clearFirestoreData();
  });

  test('should add and get a user', () async {
    final userId = 'user1';
    final userData = UsersAddData(displayName: 'Test User', email: 'test@example.com');

    await usersCollection.set(userId, userData);
    final fetchedUser = await usersCollection.get(userId);

    expect(fetchedUser, isNotNull);
    expect(fetchedUser?.displayName, userData.displayName);
    expect(fetchedUser?.email, userData.email);
  });

  test('should query users', () async {
     await usersCollection.add(UsersAddData(displayName: 'Alice', email: 'a@e.com', age: 30));
     await usersCollection.add(UsersAddData(displayName: 'Bob', email: 'b@e.com', age: 40));

     final usersOver35 = await usersCollection.query().whereAge(isGreaterThan: 35).getData();
     expect(usersOver35, hasLength(1));
     expect(usersOver35.first.displayName, 'Bob');
  });
}
```

### Unit Testing (using Mocks/Fakes)

You can use mocking libraries (like Jest mocks in TS, Mockito/Mocktail in Dart) or fake implementations (`fake_cloud_firestore` in Dart) to test your application logic without hitting Firestore.

**Dart (using `fake_cloud_firestore`):**

```dart
import 'package:fake_cloud_firestore/fake_cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';
import 'generated/firestore_dart/users_collection.dart';
import 'generated/firestore_dart/users_data.dart';

void main() {
  test('should add and retrieve user using fake firestore', () async {
    // Use the fake instance
    final fakeFirestore = FakeFirebaseFirestore();
    final usersCollection = UsersCollection(firestore: fakeFirestore);

    final userId = 'fakeUser1';
    final userData = UsersAddData(displayName: 'Fake User', email: 'fake@example.com');

    await usersCollection.set(userId, userData);
    final fetchedUser = await usersCollection.get(userId);

    expect(fetchedUser, isNotNull);
    expect(fetchedUser?.displayName, userData.displayName);

    // Fake instance holds the data in memory
    final snapshot = await fakeFirestore.collection('users').doc(userId).get();
    expect(snapshot.exists, isTrue);
    expect(snapshot.data()?['email'], userData.email);
  });
}
```

**Choosing an Approach:**

-   Use **integration tests** for verifying core Firestore interactions, queries, security rules (if emulator supports them), and the behavior of the generated ODM code itself.
-   Use **unit tests** with mocks/fakes for testing your application's business logic that *uses* the generated ODM, isolating it from actual database calls for speed and simplicity.

The generated code provides a clear interface, making it relatively straightforward to mock or use with fake implementations in unit tests.
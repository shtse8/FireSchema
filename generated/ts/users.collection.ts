/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as ClientFirestore, DocumentReference as ClientDocumentReference, DocumentData as ClientDocumentData } from 'firebase/firestore';

// Runtime Imports - Base class and generic types
import { BaseCollectionRef } from '@shtse8/fireschema-runtime';
// Ensure all needed generic types are imported
import type { FirestoreLike, DocumentReferenceLike, CollectionReferenceLike, CollectionSchema, FieldSchema, DocumentDataLike } from '@shtse8/fireschema-runtime';

// Local Imports
import { UsersData } from './users.types.js';
import { UsersQueryBuilder } from './users.query.js';
import { UsersUpdateBuilder } from './users.update.js';




import { PostsCollection } from './users/{usersId}/posts.collection.js';



// Define types for data manipulation.
type UsersAddData = {
  displayName: UsersData['displayName'];
  email: UsersData['email'];
  createdAt?: UsersData['createdAt'];
  lastLogin?: UsersData['lastLogin'];
  age?: UsersData['age'];
  isActive?: UsersData['isActive'];
  settings?: UsersData['settings'];
  tags?: UsersData['tags'];
  primaryAddressRef?: UsersData['primaryAddressRef'];
};

/**
 * Typed reference to the 'users' collection, extending BaseCollectionRef.
 */
export class UsersCollection extends BaseCollectionRef<UsersData, UsersAddData> {

  /**
   * @param firestore The Firestore instance (client or admin).
   * @param parentRef Optional DocumentReference of the parent document (for subcollections).
   */
  // Simplified constructor: Accepts only firestore and optional parentRef
  constructor(
    firestore: FirestoreLike,
    parentRef?: DocumentReferenceLike<DocumentDataLike> // Use generic type
  ) {
    // Process fields to create schema for runtime base class
    const processedFields: Record<string, FieldSchema> = {};
    
      processedFields['displayName'] = {
        
      };
    
      processedFields['email'] = {
        
      };
    
      processedFields['createdAt'] = {
        
        defaultValue: "serverTimestamp",
        
      };
    
      processedFields['lastLogin'] = {
        
      };
    
      processedFields['age'] = {
        
      };
    
      processedFields['isActive'] = {
        
        defaultValue: true,
        
      };
    
      processedFields['settings'] = {
        
      };
    
      processedFields['tags'] = {
        
      };
    
      processedFields['primaryAddressRef'] = {
        
      };
    
    const schemaForRuntime: CollectionSchema = { fields: processedFields };

    // Call the base class constructor, providing the hardcoded collectionId
    // Base class constructor: (firestore, collectionId, schema?, parentRef?)
    super(firestore, 'users', schemaForRuntime, parentRef);
  }

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   */
  update(id: string): UsersUpdateBuilder {
    return new UsersUpdateBuilder(this.doc(id));
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   */
  query(): UsersQueryBuilder {
    return new UsersQueryBuilder(this.firestore, this.ref);
  }

  // --- Subcollection Accessors ---




  /**
   * Access the 'posts' subcollection for a specific document.
   */
  posts(documentId: string): PostsCollection {
    // Process subcollection fields
    const processedSubFields: Record<string, FieldSchema> = {};
    
      processedSubFields['title'] = {
        
      };
    
      processedSubFields['content'] = {
        
      };
    
      processedSubFields['publishedAt'] = {
        
      };
    
    const subSchema: CollectionSchema = { fields: processedSubFields };
    // Use the subCollection helper from BaseCollectionRef
    // It expects: parentId, subCollectionId, SubCollectionClass, subSchema?
    return this.subCollection(documentId, 'posts', PostsCollection, subSchema);
  }



  // --- Custom Methods Placeholder ---
}
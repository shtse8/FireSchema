/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  Firestore,
  CollectionReference,
  DocumentReference,
  collection,
  doc,
  getDoc,
  addDoc,
  setDoc,
  updateDoc,
  deleteDoc,
  serverTimestamp,
  increment,
  arrayUnion,
  arrayRemove,
  deleteField,
  // TODO: Add query imports: query, where, orderBy, limit, startAt, endAt etc.
} from 'firebase/firestore';
import { UsersData } from './users.types'; // Import the generated model type
import { UsersQueryBuilder } from './users.query'; // Import the generated query builder
import { UsersUpdateBuilder } from './users.update'; // Import the generated update builder

// Define types for data manipulation.
// AddData: Exclude fields that should not be provided on creation (e.g., read-only fields managed by Firestore).
// UpdateData: Make all fields optional for partial updates.
// TODO: Refine which fields are Omitted based on schema (e.g., fields with defaultValue: serverTimestamp?)
// Note: For UpdateData, the type should allow FieldValue types (increment, arrayUnion, etc.)
//       This is complex to type perfectly, so we use Partial<> for now, and users must
//       ensure they pass the correct FieldValue types where needed.
type UsersAddData = Omit<UsersData, 'createdAt' /* Add other read-only fields here */>;
type UsersUpdateData = Partial<UsersAddData>;

/**
 * Typed reference to the 'users' collection.
 */
export class UsersCollection {
  public ref: CollectionReference<UsersData>;

  private firestore: Firestore; // Store firestore instance

  constructor(firestore: Firestore) {
    this.firestore = firestore; // Store firestore instance
    this.ref = collection(firestore, 'users') as CollectionReference<UsersData>;
  }

  /** Returns the DocumentReference for a given ID. */
  doc(id: string): DocumentReference<UsersData> {
    return doc(this.ref, id);
  }

  /** Adds a new document with the given data, returning the new DocumentReference. */
  async add(data: UsersAddData): Promise<DocumentReference<UsersData>> {
    const dataWithDefaults = { ...data };
    // Automatically add server timestamps for fields configured in the schema
    if (!dataWithDefaults.createdAt) { // Add timestamp if not explicitly provided
        (dataWithDefaults as any).createdAt = serverTimestamp();
    }
    return addDoc(this.ref, dataWithDefaults);
  }

  /** Sets the data for a document, overwriting existing data. */
  async set(id: string, data: UsersAddData): Promise<void> {
    // Note: set might need its own data type if it should behave differently than add
    await setDoc(this.doc(id), data);
  }

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   * @param id The ID of the document to update.
   * @returns A new UpdateBuilder instance.
   */
  update(id: string): UsersUpdateBuilder {
    return new UsersUpdateBuilder(this.doc(id));
  }

  /** Deletes a document. */
  async delete(id: string): Promise<void> {
    await deleteDoc(this.doc(id));
  }

  /** Reads a single document. */
  async get(id: string): Promise<UsersData | undefined> {
    const snapshot = await getDoc(this.doc(id));
    return snapshot.exists() ? snapshot.data() : undefined;
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   * @returns A new QueryBuilder instance.
   */
  query(): UsersQueryBuilder {
    return new UsersQueryBuilder(this.firestore, this.ref);
  }

  // Example: findByEmail(email: string) { ... }
  // Example: listActiveUsers(limitCount: number) { ... }

  // --- Helper for data conversion? ---
  // Maybe add private methods for converting data before writes (e.g., handling default values)
}
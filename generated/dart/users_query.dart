/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
import './users_data.dart'; // Import the generated model type

/// Typed query builder for the 'users' collection.
class UsersQueryBuilder {
  final FirebaseFirestore firestore;
  final CollectionReference<UsersData> collectionRef;
  Query<UsersData> _query; // Internal query state

  UsersQueryBuilder(this.firestore, this.collectionRef) : _query = collectionRef;

  /// Creates a new query builder instance with the applied query constraints.
  UsersQueryBuilder._(this.firestore, this.collectionRef, this._query);

// --- Field-specific Where Methods ---
  /// Adds a query filter for the 'displayName' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, isLessThan, isLessThanOrEqualTo, isGreaterThan, isGreaterThanOrEqualTo, whereIn, whereNotIn
  UsersQueryBuilder whereDisplayName({
    String isEqualTo,
    String isNotEqualTo,
    String isLessThan,
    String isLessThanOrEqualTo,
    String isGreaterThan,
    String isGreaterThanOrEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('displayName', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('displayName', isNotEqualTo: isNotEqualTo);
    if (isLessThan != null) newQuery = newQuery.where('displayName', isLessThan: isLessThan);
    if (isLessThanOrEqualTo != null) newQuery = newQuery.where('displayName', isLessThanOrEqualTo: isLessThanOrEqualTo);
    if (isGreaterThan != null) newQuery = newQuery.where('displayName', isGreaterThan: isGreaterThan);
    if (isGreaterThanOrEqualTo != null) newQuery = newQuery.where('displayName', isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    if (whereIn != null) newQuery = newQuery.where('displayName', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('displayName', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'email' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, isLessThan, isLessThanOrEqualTo, isGreaterThan, isGreaterThanOrEqualTo, whereIn, whereNotIn
  UsersQueryBuilder whereEmail({
    String isEqualTo,
    String isNotEqualTo,
    String isLessThan,
    String isLessThanOrEqualTo,
    String isGreaterThan,
    String isGreaterThanOrEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('email', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('email', isNotEqualTo: isNotEqualTo);
    if (isLessThan != null) newQuery = newQuery.where('email', isLessThan: isLessThan);
    if (isLessThanOrEqualTo != null) newQuery = newQuery.where('email', isLessThanOrEqualTo: isLessThanOrEqualTo);
    if (isGreaterThan != null) newQuery = newQuery.where('email', isGreaterThan: isGreaterThan);
    if (isGreaterThanOrEqualTo != null) newQuery = newQuery.where('email', isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    if (whereIn != null) newQuery = newQuery.where('email', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('email', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'createdAt' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, isLessThan, isLessThanOrEqualTo, isGreaterThan, isGreaterThanOrEqualTo, whereIn, whereNotIn
  UsersQueryBuilder whereCreatedAt({
    Timestamp? isEqualTo,
    Timestamp? isNotEqualTo,
    Timestamp? isLessThan,
    Timestamp? isLessThanOrEqualTo,
    Timestamp? isGreaterThan,
    Timestamp? isGreaterThanOrEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('createdAt', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('createdAt', isNotEqualTo: isNotEqualTo);
    if (isLessThan != null) newQuery = newQuery.where('createdAt', isLessThan: isLessThan);
    if (isLessThanOrEqualTo != null) newQuery = newQuery.where('createdAt', isLessThanOrEqualTo: isLessThanOrEqualTo);
    if (isGreaterThan != null) newQuery = newQuery.where('createdAt', isGreaterThan: isGreaterThan);
    if (isGreaterThanOrEqualTo != null) newQuery = newQuery.where('createdAt', isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    if (whereIn != null) newQuery = newQuery.where('createdAt', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('createdAt', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'lastLogin' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, isLessThan, isLessThanOrEqualTo, isGreaterThan, isGreaterThanOrEqualTo, whereIn, whereNotIn
  UsersQueryBuilder whereLastLogin({
    Timestamp? isEqualTo,
    Timestamp? isNotEqualTo,
    Timestamp? isLessThan,
    Timestamp? isLessThanOrEqualTo,
    Timestamp? isGreaterThan,
    Timestamp? isGreaterThanOrEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('lastLogin', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('lastLogin', isNotEqualTo: isNotEqualTo);
    if (isLessThan != null) newQuery = newQuery.where('lastLogin', isLessThan: isLessThan);
    if (isLessThanOrEqualTo != null) newQuery = newQuery.where('lastLogin', isLessThanOrEqualTo: isLessThanOrEqualTo);
    if (isGreaterThan != null) newQuery = newQuery.where('lastLogin', isGreaterThan: isGreaterThan);
    if (isGreaterThanOrEqualTo != null) newQuery = newQuery.where('lastLogin', isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    if (whereIn != null) newQuery = newQuery.where('lastLogin', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('lastLogin', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'age' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, isLessThan, isLessThanOrEqualTo, isGreaterThan, isGreaterThanOrEqualTo, whereIn, whereNotIn
  UsersQueryBuilder whereAge({
    num? isEqualTo,
    num? isNotEqualTo,
    num? isLessThan,
    num? isLessThanOrEqualTo,
    num? isGreaterThan,
    num? isGreaterThanOrEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('age', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('age', isNotEqualTo: isNotEqualTo);
    if (isLessThan != null) newQuery = newQuery.where('age', isLessThan: isLessThan);
    if (isLessThanOrEqualTo != null) newQuery = newQuery.where('age', isLessThanOrEqualTo: isLessThanOrEqualTo);
    if (isGreaterThan != null) newQuery = newQuery.where('age', isGreaterThan: isGreaterThan);
    if (isGreaterThanOrEqualTo != null) newQuery = newQuery.where('age', isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    if (whereIn != null) newQuery = newQuery.where('age', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('age', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'isActive' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, isLessThan, isLessThanOrEqualTo, isGreaterThan, isGreaterThanOrEqualTo, whereIn, whereNotIn
  UsersQueryBuilder whereIsActive({
    bool? isEqualTo,
    bool? isNotEqualTo,
    bool? isLessThan,
    bool? isLessThanOrEqualTo,
    bool? isGreaterThan,
    bool? isGreaterThanOrEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('isActive', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('isActive', isNotEqualTo: isNotEqualTo);
    if (isLessThan != null) newQuery = newQuery.where('isActive', isLessThan: isLessThan);
    if (isLessThanOrEqualTo != null) newQuery = newQuery.where('isActive', isLessThanOrEqualTo: isLessThanOrEqualTo);
    if (isGreaterThan != null) newQuery = newQuery.where('isActive', isGreaterThan: isGreaterThan);
    if (isGreaterThanOrEqualTo != null) newQuery = newQuery.where('isActive', isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    if (whereIn != null) newQuery = newQuery.where('isActive', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('isActive', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'settings' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, whereIn, whereNotIn
  UsersQueryBuilder whereSettings({
    Map<String, dynamic>? isEqualTo,
    Map<String, dynamic>? isNotEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('settings', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('settings', isNotEqualTo: isNotEqualTo);
    if (whereIn != null) newQuery = newQuery.where('settings', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('settings', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'tags' field.
  ///
  /// Available filter parameters: arrayContains, arrayContainsAny, whereIn, whereNotIn
  UsersQueryBuilder whereTags({
    String? arrayContains,
    List<List<String>> arrayContainsAny,
    List<List<String>> whereIn,
    List<List<String>> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (arrayContains != null) newQuery = newQuery.where('tags', arrayContains: arrayContains);
    if (arrayContainsAny != null) newQuery = newQuery.where('tags', arrayContainsAny: arrayContainsAny);
    if (whereIn != null) newQuery = newQuery.where('tags', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('tags', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  /// Adds a query filter for the 'primaryAddressRef' field.
  ///
  /// Available filter parameters: isEqualTo, isNotEqualTo, isLessThan, isLessThanOrEqualTo, isGreaterThan, isGreaterThanOrEqualTo, whereIn, whereNotIn
  UsersQueryBuilder wherePrimaryAddressRef({
    DocumentReference<Map<String, dynamic>>? isEqualTo,
    DocumentReference<Map<String, dynamic>>? isNotEqualTo,
    DocumentReference<Map<String, dynamic>>? isLessThan,
    DocumentReference<Map<String, dynamic>>? isLessThanOrEqualTo,
    DocumentReference<Map<String, dynamic>>? isGreaterThan,
    DocumentReference<Map<String, dynamic>>? isGreaterThanOrEqualTo,
    List<dynamic> whereIn,
    List<dynamic> whereNotIn
  }) {
    Query<UsersData> newQuery = _query;
    if (isEqualTo != null) newQuery = newQuery.where('primaryAddressRef', isEqualTo: isEqualTo);
    if (isNotEqualTo != null) newQuery = newQuery.where('primaryAddressRef', isNotEqualTo: isNotEqualTo);
    if (isLessThan != null) newQuery = newQuery.where('primaryAddressRef', isLessThan: isLessThan);
    if (isLessThanOrEqualTo != null) newQuery = newQuery.where('primaryAddressRef', isLessThanOrEqualTo: isLessThanOrEqualTo);
    if (isGreaterThan != null) newQuery = newQuery.where('primaryAddressRef', isGreaterThan: isGreaterThan);
    if (isGreaterThanOrEqualTo != null) newQuery = newQuery.where('primaryAddressRef', isGreaterThanOrEqualTo: isGreaterThanOrEqualTo);
    if (whereIn != null) newQuery = newQuery.where('primaryAddressRef', whereIn: whereIn);
    if (whereNotIn != null) newQuery = newQuery.where('primaryAddressRef', whereNotIn: whereNotIn);
    // It's recommended to only pass one operator per where<FieldName> call.
    // If multiple are passed, Firestore behavior might be unexpected or unsupported.
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }
  // --- End Field-specific Where Methods ---

   /// Adds an orderBy clause to the query.
  UsersQueryBuilder orderBy(String fieldPath, {bool descending = false}) {
     final newQuery = _query.orderBy(fieldPath, descending: descending);
     return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Adds a limit clause to the query.
  UsersQueryBuilder limit(int limit) {
     final newQuery = _query.limit(limit);
     return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }


  /// Adds a limitToLast clause to the query.
  UsersQueryBuilder limitToLast(int limit) {
     final newQuery = _query.limitToLast(limit);
     return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to start at the provided document
  /// (inclusive). The starting position is relative to the order of the query.
  UsersQueryBuilder startAtDocument(DocumentSnapshot documentSnapshot) {
    final newQuery = _query.startAtDocument(documentSnapshot);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to start at the provided fields
  /// (inclusive). The starting position is relative to the order of the query.
  UsersQueryBuilder startAt(List<Object?> fieldValues) {
    final newQuery = _query.startAt(fieldValues);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to start after the provided document
  /// (exclusive). The starting position is relative to the order of the query.
  UsersQueryBuilder startAfterDocument(DocumentSnapshot documentSnapshot) {
    final newQuery = _query.startAfterDocument(documentSnapshot);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to start after the provided fields
  /// (exclusive). The starting position is relative to the order of the query.
  UsersQueryBuilder startAfter(List<Object?> fieldValues) {
    final newQuery = _query.startAfter(fieldValues);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to end before the provided document
  /// (exclusive). The ending position is relative to the order of the query.
  UsersQueryBuilder endBeforeDocument(DocumentSnapshot documentSnapshot) {
    final newQuery = _query.endBeforeDocument(documentSnapshot);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to end before the provided fields
  /// (exclusive). The ending position is relative to the order of the query.
  UsersQueryBuilder endBefore(List<Object?> fieldValues) {
    final newQuery = _query.endBefore(fieldValues);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to end at the provided document
  /// (inclusive). The ending position is relative to the order of the query.
  UsersQueryBuilder endAtDocument(DocumentSnapshot documentSnapshot) {
    final newQuery = _query.endAtDocument(documentSnapshot);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  /// Creates a query constraint that modifies the query to end at the provided fields
  /// (inclusive). The ending position is relative to the order of the query.
  UsersQueryBuilder endAt(List<Object?> fieldValues) {
    final newQuery = _query.endAt(fieldValues);
    return UsersQueryBuilder._(firestore, collectionRef, newQuery);
  }

  // TODO: Add limitToLast, startAt, startAfter, endAt, endBefore methods

  /// Executes the query and returns the matching documents.
  Future<List<UsersData>> get() async {
    final snapshot = await _query.get();
    return snapshot.docs.map((doc) => doc.data()).toList();
     // TODO: Consider returning document IDs as well
  }

   /// Executes the query and returns a stream of matching documents.
  Stream<List<UsersData>> snapshots() {
    return _query.snapshots().map((snapshot) =>
        snapshot.docs.map((doc) => doc.data()).toList());
  }
}
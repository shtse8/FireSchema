/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import runtime types
// Import other necessary packages if needed

<%# Helper function to get Dart type - defined within the template for simplicity %>
<%_
const getDartType = (field, options) => {
  // TODO: Add option for DateTime vs Timestamp
  switch (field.type) {
    case 'string': return 'String';
    case 'number': return 'num'; // Or double/int based on further schema info?
    case 'boolean': return 'bool';
    case 'timestamp': return 'Timestamp'; // from cloud_firestore
    case 'geopoint': return 'GeoPoint'; // from cloud_firestore
    case 'reference':
      const refModelName = field.referenceTo ? camelToPascalCase(field.referenceTo) + 'Data' : 'DocumentSnapshot';
      // DocumentReference itself isn't generic in the same way in Dart firestore client.
      return `DocumentReference<Map<String, dynamic>>`; // Or DocumentReference?
    case 'array':
      if (!field.items) return 'List<dynamic>';
      return `List<${getDartType(field.items, options)}>`;
    case 'map':
      if (!field.properties) return 'Map<String, dynamic>';
      // TODO: Generate typed map class if possible/desired
      return 'Map<String, dynamic>';
    default: return 'dynamic';
  }
};
_%>

/// Represents the data structure for a '<%- modelName %>' document.
/// Description: <%- collection.description || 'N/A' %>
class <%- modelName %>Data {
<% Object.values(collection.fields).forEach(field => { -%>
  /// <%- field.description || field.fieldName %> (<%- field.type %><%- field.required ? ', required' : '' %>)
  final <%- getDartType(field, options) %><%- field.required ? '' : '?' %> <%- field.fieldName %>;
<% }); -%>

  const <%- modelName %>Data({
<% Object.values(collection.fields).forEach(field => { -%>
    <%- field.required ? 'required ' : '' %>this.<%- field.fieldName %>,
<% }); -%>
  });

  /// Creates a <%- modelName %>Data instance from a Firestore DocumentSnapshot.
  factory <%- modelName %>Data.fromSnapshot(DocumentSnapshot snapshot) {
    final data = snapshot.data() as Map<String, dynamic>?;
    if (data == null) {
        throw Exception("Document data was null on snapshot ${snapshot.id}!");
    }
    return <%- modelName %>Data.fromJson(data); // Reuse fromJson logic
  }

   /// Creates a <%- modelName %>Data instance from a Map.
  factory <%- modelName %>Data.fromJson(Map<String, dynamic> data) {
     return <%- modelName %>Data(
<% Object.values(collection.fields).forEach(field => { -%>
<%   const dartType = getDartType(field, options); %>
<%   const isNullable = !field.required; %>
<%   const fieldAccess = `data['${field.fieldName}']`; %>
<%   let parsingLogic; %>
<%   if (field.type === 'array' && field.items) { %>
<%     const itemType = getDartType(field.items, options); %>
<%     // Handle list parsing with type casting for items %>
<%     parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`; %>
<%   } else if (field.type === 'map') { %>
<%     // Basic map parsing, TODO: Needs recursive parsing for nested typed maps %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else if (field.type === 'timestamp') { %>
<%     // Timestamps are handled directly by Firestore SDK types when reading from snapshot %>
<%     // If reading from generic JSON, might need Timestamp.fromDate(DateTime.parse(value)) %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else if (field.type === 'geopoint') { %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else if (field.type === 'reference') { %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else { %>
<%     // Default casting for primitives (String, num, bool) %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } %>
      <%- field.fieldName %>: <%- parsingLogic %><%- isNullable ? '' : ` ?? (throw Exception("Missing required field: ${field.fieldName} in $data"))` %>,
<% }); -%>
    );
  }

  /// Creates a <%- modelName %>Data instance from a Firestore DocumentSnapshot.
  /// Required for Firestore `withConverter`.
  factory <%- modelName %>Data.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
    SnapshotOptions? options,
  ) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Snapshot data was null!');
    }
    // We can reuse the existing fromJson logic.
    // Add the document ID to the data map if you want it in the model.
    // data['id'] = snapshot.id; // Optional: include document ID
    return <%- modelName %>Data.fromJson(data);
  }

  /// Converts this <%- modelName %>Data instance to a Map suitable for Firestore.
  Map<String, dynamic> toJson() {
    return {
<% Object.values(collection.fields).forEach(field => { -%>
<%   let valueAccess = field.fieldName; %>
<%   // TODO: Add recursive toJson calls for nested maps/lists if they have toJson methods %>
<%   // Example for a list of objects with toJson: %>
<%   // if (field.type === 'array' && field.items && field.items.type === 'map') { %>
<%   //   valueAccess = `${field.fieldName}?.map((e) => e.toJson()).toList()`; %>
<%   // } else if (field.type === 'map') { %>
<%   //   valueAccess = `${field.fieldName}?.toJson()`; %>
<%   // } %>
      '<%- field.fieldName %>': <%- valueAccess %>,
<% }); -%>
    };
  }

  /// Converts this <%- modelName %>Data instance to a Map suitable for Firestore.
  /// Required for Firestore `withConverter`.
  Map<String, Object?> toFirestore(SetOptions? options) {
    // We can reuse the existing toJson logic.
    // Firestore expects Map<String, Object?>
    return toJson();
  }

  /// Creates a copy of this instance with potentially modified fields.
  <%- modelName %>Data copyWith({
<% Object.values(collection.fields).forEach(field => { -%>
    <%- getDartType(field, options) %>? <%- field.fieldName %>,
<% }); -%>
  }) {
    return <%- modelName %>Data(
<% Object.values(collection.fields).forEach(field => { -%>
      <%- field.fieldName %>: <%- field.fieldName %> ?? this.<%- field.fieldName %>,
<% }); -%>
    );
  }
} // End of <%- modelName %>Data class

  // TODO: Add toString, equals, hashCode implementations?


/// Represents the data structure for adding a new '<%- modelName %>' document.
/// Fields with default values (like server timestamps) or optional fields are nullable.
class <%- modelName %>AddData implements ToJsonSerializable {
<% Object.values(collection.fields).forEach(field => { -%>
<%   const dartType = getDartType(field, options); %>
<%   // Determine if the field should be required in AddData
   // Required if: it's marked required in schema AND has no default value
   // Optional if: it's not required OR it has a default value
   const isRequiredForAdd = field.required && !field.defaultValue;
   const isOptionalForAdd = !field.required || !!field.defaultValue;
%>
  final <%- dartType %><%- isOptionalForAdd ? '?' : '' %> <%- field.fieldName %>;
<% }); -%>

  const <%- modelName %>AddData({
<% Object.values(collection.fields).forEach(field => { -%>
<%   const isRequiredForAdd = field.required && !field.defaultValue; %>
    <%- isRequiredForAdd ? 'required ' : '' %>this.<%- field.fieldName %>,
<% }); -%>
  });

  /// Converts this instance to a Map suitable for Firestore add operation.
  /// Excludes fields that are null to avoid overwriting server-generated values.
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};
<% Object.values(collection.fields).forEach(field => { -%>
<%   const isOptionalForAdd = !field.required || !!field.defaultValue; %>
<%   if (isOptionalForAdd) { -%>
    // Only include non-null values in the map for optional fields
    if (<%- field.fieldName %> != null) {
      // TODO: Handle nested toJson if needed for complex types
      map['<%- field.fieldName %>'] = <%- field.fieldName %>;
    }
<%   } else { -%>
    // Required fields are always included
    // TODO: Handle nested toJson if needed for complex types
    map['<%- field.fieldName %>'] = <%- field.fieldName %>;
<%   } -%>
<% }); -%>
    return map;
  }
}
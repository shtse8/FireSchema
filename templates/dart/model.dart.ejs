/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
// Import other necessary packages if needed

<%# Helper function to get Dart type - defined within the template for simplicity %>
<%_
const getDartType = (field, options) => {
  // TODO: Add option for DateTime vs Timestamp
  switch (field.type) {
    case 'string': return 'String';
    case 'number': return 'num'; // Or double/int based on further schema info?
    case 'boolean': return 'bool';
    case 'timestamp': return 'Timestamp'; // from cloud_firestore
    case 'geopoint': return 'GeoPoint'; // from cloud_firestore
    case 'reference':
      const refModelName = field.referenceTo ? camelToPascalCase(field.referenceTo) + 'Data' : 'DocumentSnapshot';
      // DocumentReference itself isn't generic in the same way in Dart firestore client.
      return `DocumentReference<Map<String, dynamic>>`; // Or DocumentReference?
    case 'array':
      if (!field.items) return 'List<dynamic>';
      return `List<${getDartType(field.items, options)}>`;
    case 'map':
      if (!field.properties) return 'Map<String, dynamic>';
      // TODO: Generate typed map class if possible/desired
      return 'Map<String, dynamic>';
    default: return 'dynamic';
  }
};
_%>

/// Represents the data structure for a '<%- modelName %>' document.
/// Description: <%- collection.description || 'N/A' %>
class <%- modelName %>Data {
<% Object.values(collection.fields).forEach(field => { -%>
  /// <%- field.description || field.fieldName %> (<%- field.type %><%- field.required ? ', required' : '' %>)
  final <%- getDartType(field, options) %><%- field.required ? '' : '?' %> <%- field.fieldName %>;
<% }); -%>

  const <%- modelName %>Data({
<% Object.values(collection.fields).forEach(field => { -%>
    <%- field.required ? 'required ' : '' %>this.<%- field.fieldName %>,
<% }); -%>
  });

  /// Creates a <%- modelName %>Data instance from a Firestore DocumentSnapshot.
  factory <%- modelName %>Data.fromSnapshot(DocumentSnapshot snapshot) {
    final data = snapshot.data() as Map<String, dynamic>?;
    if (data == null) {
        throw Exception("Document data was null on snapshot ${snapshot.id}!");
    }
    return <%- modelName %>Data.fromJson(data); // Reuse fromJson logic
  }

   /// Creates a <%- modelName %>Data instance from a Map.
  factory <%- modelName %>Data.fromJson(Map<String, dynamic> data) {
     return <%- modelName %>Data(
<% Object.values(collection.fields).forEach(field => { -%>
<%   const dartType = getDartType(field, options); %>
<%   const isNullable = !field.required; %>
<%   const fieldAccess = `data['${field.fieldName}']`; %>
<%   let parsingLogic; %>
<%   if (field.type === 'array' && field.items) { %>
<%     const itemType = getDartType(field.items, options); %>
<%     // Handle list parsing with type casting for items %>
<%     parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`; %>
<%   } else if (field.type === 'map') { %>
<%     // Basic map parsing, TODO: Needs recursive parsing for nested typed maps %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else if (field.type === 'timestamp') { %>
<%     // Timestamps are handled directly by Firestore SDK types when reading from snapshot %>
<%     // If reading from generic JSON, might need Timestamp.fromDate(DateTime.parse(value)) %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else if (field.type === 'geopoint') { %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else if (field.type === 'reference') { %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } else { %>
<%     // Default casting for primitives (String, num, bool) %>
<%     parsingLogic = `${fieldAccess} as ${dartType}?`; %>
<%   } %>
      <%- field.fieldName %>: <%- parsingLogic %><%- isNullable ? '' : ` ?? (throw Exception("Missing required field: ${field.fieldName} in $data"))` %>,
<% }); -%>
    );
  }

  /// Converts this <%- modelName %>Data instance to a Map suitable for Firestore.
  Map<String, dynamic> toJson() {
    return {
<% Object.values(collection.fields).forEach(field => { -%>
<%   let valueAccess = field.fieldName; %>
<%   // TODO: Add recursive toJson calls for nested maps/lists if they have toJson methods %>
<%   // Example for a list of objects with toJson: %>
<%   // if (field.type === 'array' && field.items && field.items.type === 'map') { %>
<%   //   valueAccess = `${field.fieldName}?.map((e) => e.toJson()).toList()`; %>
<%   // } else if (field.type === 'map') { %>
<%   //   valueAccess = `${field.fieldName}?.toJson()`; %>
<%   // } %>
      '<%- field.fieldName %>': <%- valueAccess %>,
<% }); -%>
    };
  }

  /// Creates a copy of this instance with potentially modified fields.
  <%- modelName %>Data copyWith({
<% Object.values(collection.fields).forEach(field => { -%>
    <%- getDartType(field, options) %>? <%- field.fieldName %>,
<% }); -%>
  }) {
    return <%- modelName %>Data(
<% Object.values(collection.fields).forEach(field => { -%>
      <%- field.fieldName %>: <%- field.fieldName %> ?? this.<%- field.fieldName %>,
<% }); -%>
    );
  }

  // TODO: Add toString, equals, hashCode implementations?
}
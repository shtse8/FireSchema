/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import runtime types
// Import other necessary packages if needed

<%# --- EJS Helper Functions --- %>
<%_
// Keep track of generated nested classes to avoid duplicates
const generatedNestedClasses = new Set();

// --- Type Generation ---
const getNestedClassName = (parentModelName, fieldName) => {
  return `${parentModelName}${camelToPascalCase(fieldName)}Map`;
};

const getDartType = (field, options, parentModelName) => {
  switch (field.type) {
    case 'string': return 'String';
    case 'number': return 'num';
    case 'boolean': return 'bool';
    case 'timestamp': return 'Timestamp';
    case 'geopoint': return 'GeoPoint';
    case 'reference': return `DocumentReference<Map<String, dynamic>>`; // Use literal < >
    case 'array':
      if (!field.items) return 'List<dynamic>'; // Use literal < >
      return `List<${getDartType(field.items, options, parentModelName)}>`; // Use literal < >
    case 'map':
      if (field.properties && Object.keys(field.properties).length > 0) { // Use literal >
        return getNestedClassName(parentModelName, field.fieldName);
      }
      return 'Map<String, dynamic>'; // Use literal < >
    default: return 'dynamic';
  }
};

// --- fromJson Logic Generation ---
const generateFromJsonLogic = (field, options, parentModelName) => {
  const dartType = getDartType(field, options, parentModelName);
  const isNullable = !field.required;
  const fieldAccess = `data['${field.fieldName}']`;
  let parsingLogic = '';

  switch (field.type) {
    case 'array':
      if (!field.items) {
        parsingLogic = `${fieldAccess} as List<dynamic>?`; // Use literal < >
      } else {
        const itemType = getDartType(field.items, options, parentModelName);
        const itemIsNestedClass = field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0; // Use literal >

        if (itemIsNestedClass) {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => ${itemType}.fromJson(e as Map<String, dynamic>)).toList()`; // Use literal < >
        } else if (['timestamp', 'geopoint', 'reference'].includes(field.items.type)) {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`; // Use literal < >
        } else if (field.items.type === 'array' || field.items.type === 'map') {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`; // Use literal < >
        } else {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`; // Use literal < >
        }
      }
      break;
    case 'map':
      if (field.properties && Object.keys(field.properties).length > 0) { // Use literal >
        parsingLogic = `${fieldAccess} == null ? null : ${dartType}.fromJson(${fieldAccess} as Map<String, dynamic>)`; // Use literal < >
      } else {
        parsingLogic = `${fieldAccess} as ${dartType}?`;
      }
      break;
    case 'timestamp':
    case 'geopoint':
    case 'reference':
      parsingLogic = `${fieldAccess} as ${dartType}?`;
      break;
    default:
      parsingLogic = `${fieldAccess} as ${dartType}?`;
      break;
  }

  if (!isNullable) {
    parsingLogic += ` ?? (throw Exception("Missing required field: ${field.fieldName} in input data"))`;
  }
  return parsingLogic;
};

// --- toJson Logic Generation ---
const generateToJsonLogic = (field, options, parentModelName) => {
   let valueAccess = field.fieldName;
   switch (field.type) {
       case 'array':
           if (field.items && field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0) { // Use literal >
               valueAccess = `${field.fieldName}?.map((e) => e.toJson()).toList()`;
           }
           break;
       case 'map':
           if (field.properties && Object.keys(field.properties).length > 0) { // Use literal >
               valueAccess = `${field.fieldName}?.toJson()`;
           }
           break;
   }
   return valueAccess;
};

// --- Assertion Generation ---
const generateAssertionBodyStrings = (className, fields) => {
  let assertionStrings = [];
  Object.values(fields).forEach(field => {
    const isNullable = !field.required;
    const nullCheck = isNullable ? `(${field.fieldName} == null || ` : '';
    const closeNullCheck = isNullable ? ')' : '';

    if (field.type === 'string') {
      if (field.minLength != null) {
        assertionStrings.push(`assert(${nullCheck}${field.fieldName}.length >= ${field.minLength}${closeNullCheck}, '${className}.${field.fieldName} must be at least ${field.minLength} characters long');`); // Use literal >=
      }
      if (field.maxLength != null) {
         assertionStrings.push(`assert(${nullCheck}${field.fieldName}.length <= ${field.maxLength}${closeNullCheck}, '${className}.${field.fieldName} must be at most ${field.maxLength} characters long');`); // Use literal <=
      }
      if (field.pattern != null) {
        const dartPattern = field.pattern.replace(/\\/g, '\\\\');
        assertionStrings.push(`assert(${nullCheck}RegExp(r'${dartPattern}').hasMatch(${field.fieldName})${closeNullCheck}, '${className}.${field.fieldName} must match pattern: ${field.pattern}');`);
      }
    } else if (field.type === 'number') {
      if (field.minimum != null) {
        assertionStrings.push(`assert(${nullCheck}${field.fieldName} >= ${field.minimum}${closeNullCheck}, '${className}.${field.fieldName} must be >= ${field.minimum}');`); // Use literal >=
      }
      if (field.maximum != null) {
        assertionStrings.push(`assert(${nullCheck}${field.fieldName} <= ${field.maximum}${closeNullCheck}, '${className}.${field.fieldName} must be <= ${field.maximum}');`); // Use literal <=
      }
    }
  });
  return assertionStrings;
};


// --- Main Class Generation Function ---
const prepareClassData = (className, fields, options, isNested = false, collectionDescription = null) => {
  const classData = {
      className: className,
      isNested: isNested,
      collectionDescription: collectionDescription,
      fields: fields,
      options: options,
      implementsToJson: isNested ? 'implements ToJsonSerializable ' : '',
      dataSuffix: isNested ? '' : 'Data',
      fieldStrings: Object.values(fields).map(field => {
          const fieldDartType = getDartType(field, options, className);
          return `  /// ${field.description || field.fieldName} (${field.type}${field.required ? ', required' : ''})\n  final ${fieldDartType}${field.required ? '' : '?'} ${field.fieldName};`;
      }).join('\n'),
      constructorParams: Object.values(fields).map(field => `    ${field.required ? 'required ' : ''}this.${field.fieldName},`).join('\n'),
      assertions: generateAssertionBodyStrings(className, fields), // Get assertions as an array for the body
      fromJsonParams: Object.values(fields).map(field => `      ${field.fieldName}: ${generateFromJsonLogic(field, options, className)},`).join('\n'),
      toJsonEntries: Object.values(fields).map(field => `      '${field.fieldName}': ${generateToJsonLogic(field, options, className)},`).join('\n'),
      copyWithParams: Object.values(fields).map(field => `    ${getDartType(field, options, className)}? ${field.fieldName},`).join('\n'),
      copyWithBody: Object.values(fields).map(field => `      ${field.fieldName}: ${field.fieldName} ?? this.${field.fieldName},`).join('\n'),
  };
  return classData;
};

// --- AddData Class Generation ---
const prepareAddData = (modelName, fields, options) => {
    const addFields = Object.values(fields).filter(field => !field['x-read-only']);
    const fieldStrings = addFields.map(field => {
        const dartType = getDartType(field, options, modelName);
        const isOptionalForAdd = !field.required || !!field.defaultValue;
        return `  /// ${field.description || field.fieldName} (${field.type}${field.required && !field.defaultValue ? ', required' : ''})\n  final ${dartType}${isOptionalForAdd ? '?' : ''} ${field.fieldName};`; // Use literal &&
    }).join('\n');

    const constructorParams = addFields.map(field => {
        const isRequiredForAdd = field.required && !field.defaultValue; // Use literal &&
        return `    ${isRequiredForAdd ? 'required ' : ''}this.${field.fieldName},`;
    }).join('\n');

    const toJsonEntries = addFields.map(field => {
        const isOptionalForAdd = !field.required || !!field.defaultValue;
        const toJsonLogic = generateToJsonLogic(field, options, modelName);
        if (isOptionalForAdd) {
            return `    if (${field.fieldName} != null) {\n      map['${field.fieldName}'] = ${toJsonLogic};\n    }`;
        } else {
            return `    map['${field.fieldName}'] = ${toJsonLogic};`;
        }
    }).join('\n');

    return { modelName, fieldStrings, constructorParams, toJsonEntries };
};

// --- UpdateData Class Generation ---
const prepareUpdateData = (modelName, fields, options) => {
    const updateFields = Object.values(fields).filter(field => !field['x-read-only']);
    const fieldStrings = updateFields.map(field => {
        const dartType = getDartType(field, options, modelName);
        return `  /// ${field.description || field.fieldName} (${field.type})\n  final ${dartType}? ${field.fieldName};`;
    }).join('\n');

    const constructorParams = updateFields.map(field => `    this.${field.fieldName},`).join('\n');

    const toJsonEntries = updateFields.map(field => {
        const toJsonLogic = generateToJsonLogic(field, options, modelName);
        return `    if (${field.fieldName} != null) {\n      map['${field.fieldName}'] = ${toJsonLogic};\n    }`;
    }).join('\n');

    return { modelName, fieldStrings, constructorParams, toJsonEntries };
};

// --- Recursive generation for nested classes ---
const generateNestedClasses = (className, fields, options) => {
  let nestedClassesString = '';
  Object.values(fields).forEach(field => {
      if (field.type === 'map' && field.properties && Object.keys(field.properties).length > 0) { // Use literal >
          const nestedClassName = getNestedClassName(className, field.fieldName);
          nestedClassesString += generateSingleClass(nestedClassName, field.properties, options, true); // Recursive call
      } else if (field.type === 'array' && field.items && field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0) { // Use literal >
          const nestedClassName = getNestedClassName(className, field.items.fieldName || field.fieldName + 'Item');
          if (!generatedNestedClasses.has(nestedClassName)) {
             nestedClassesString += generateSingleClass(nestedClassName, field.items.properties, options, true);
             generatedNestedClasses.add(nestedClassName);
          }
      }
  });
  return nestedClassesString;
};

// --- Generates a single class using the template ---
const generateSingleClass = (className, fields, options, isNested = false, collectionDescription = null) => {
    const classData = prepareClassData(className, fields, options, isNested, collectionDescription);
    // Use a separate template string for the class structure
    const template = `
/// Represents the data structure for <%- isNested ? \`a nested '\${className}' map\` : \`a '\${className}' document\` %>.
<%- !isNested ? \`/// Description: ${classData.collectionDescription || 'N/A'}\` : '' %>
class <%- className %><%- dataSuffix %> <%- implementsToJson %>{

<%- fieldStrings %>

  <%- className %><%- dataSuffix %>({
<%- constructorParams %>
  }) { // Constructor body for asserts
<% if (assertions.length > 0) { %>
<%- assertions.map(a => \`    \${a}\`).join('\\n') %>
<% } %>
  } // End of constructor body

  /// Creates a <%- className %><%- dataSuffix %> instance from a Map.
  factory <%- className %><%- dataSuffix %>.fromJson(Map<String, dynamic> data) {
    return <%- className %><%- dataSuffix %>(
<%- fromJsonParams %>
    );
  }
<% if (!isNested) { %>

  /// Creates a <%- className %>Data instance from a Firestore DocumentSnapshot.
  factory <%- className %>Data.fromSnapshot(DocumentSnapshot snapshot) {
    final data = snapshot.data() as Map<String, dynamic>?;
    if (data == null) {
        throw Exception("Document data was null on snapshot ${snapshot.id}!");
    }
    return <%- className %>Data.fromJson(data);
  }

  /// Creates a <%- className %>Data instance from a Firestore DocumentSnapshot.
  /// Required for Firestore \`withConverter\`.
  factory <%- className %>Data.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
    SnapshotOptions? options,
  ) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Snapshot data was null!');
    }
    return <%- className %>Data.fromJson(data);
  }
<% } %>

  /// Converts this <%- className %><%- dataSuffix %> instance to a Map suitable for Firestore.
  Map<String, dynamic> toJson() {
    return {
<%- toJsonEntries %>
    };
  }
<% if (!isNested) { %>

  /// Converts this <%- className %>Data instance to a Map suitable for Firestore.
  /// Required for Firestore \`withConverter\`.
  Map<String, Object?> toFirestore(SetOptions? options) {
    return toJson();
  }
<% } %>

  /// Creates a copy of this instance with potentially modified fields.
  <%- className %><%- dataSuffix %> copyWith({
<%- copyWithParams %>
  }) {
    return <%- className %><%- dataSuffix %>(
<%- copyWithBody %>
    );
  }

} // End of <%- className %><%- dataSuffix %> class
`;
    return ejs.render(template, classData);
};

_ %>

<%# --- Template Output --- %>
<%- /* Generate nested classes first */ %>
<%- generateNestedClasses(modelName, collection.fields, options) %>

<%- /* Generate the main class */ %>
<%- generateSingleClass(modelName, collection.fields, options, false, collection.description) %>

<%- /* Generate AddData class */ %>
<% const addData = prepareAddData(modelName, collection.fields, options); %>
/// Represents the data structure for adding a new '<%- addData.modelName %>' document.
/// Fields with default values (like server timestamps) or optional fields are nullable.
class <%- addData.modelName %>AddData implements ToJsonSerializable {
<%- addData.fieldStrings %>

  const <%- addData.modelName %>AddData({
<%- addData.constructorParams %>
  });

  /// Converts this instance to a Map suitable for Firestore add operation.
  /// Excludes fields that are null to avoid overwriting server-generated values.
  @override // Indicate override of interface method
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};
<%- addData.toJsonEntries %>
    return map;
  }
}

<%- /* Generate UpdateData class */ %>
<% const updateData = prepareUpdateData(modelName, collection.fields, options); %>
/// Represents the data structure for updating an existing '<%- updateData.modelName %>' document.
/// All fields are optional, allowing for partial updates.
class <%- updateData.modelName %>UpdateData implements ToJsonSerializable {
<%- updateData.fieldStrings %>

  <%- updateData.modelName %>UpdateData({ // Not const
<%- updateData.constructorParams %>
  });

  /// Converts this instance to a Map suitable for Firestore update operation.
  /// Only includes fields that are not null.
  @override // Indicate override of interface method
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};
<%- updateData.toJsonEntries %>
    return map;
  }
}
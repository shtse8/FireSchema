/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import runtime types
// Import other necessary packages if needed

<%# Helper functions defined within the template %>
<%_
// Generates a PascalCase name for nested map classes
const getNestedClassName = (parentModelName, fieldName) => {
  return `${parentModelName}${camelToPascalCase(fieldName)}Map`;
};

// Determines the Dart type string for a field schema
const getDartType = (field, options, parentModelName) => {
  switch (field.type) {
    case 'string': return 'String';
    case 'number': return 'num'; // Consider int/double based on format if available
    case 'boolean': return 'bool';
    case 'timestamp': return 'Timestamp'; // from cloud_firestore
    case 'geopoint': return 'GeoPoint'; // from cloud_firestore
    case 'reference':
      // DocumentReference<T> exists but conversion happens at collection level.
      // For model fields, store as DocumentReference<Map<String, dynamic>>.
      return `DocumentReference<Map<String, dynamic>>`;
    case 'array':
      if (!field.items) return 'List<dynamic>';
      // Pass parentModelName for potential nested class names within arrays
      return `List<${getDartType(field.items, options, parentModelName)}>`;
    case 'map':
      // If the map has defined properties, generate and use a nested class type
      if (field.properties && Object.keys(field.properties).length > 0) {
        return getNestedClassName(parentModelName, field.fieldName);
      }
      // Otherwise, use a generic map
      return 'Map<String, dynamic>';
    default: return 'dynamic';
  }
};

// Generates the fromJson parsing logic for a field
const generateFromJsonLogic = (field, options, parentModelName) => {
  const dartType = getDartType(field, options, parentModelName);
  const isNullable = !field.required;
  const fieldAccess = `data['${field.fieldName}']`;
  let parsingLogic = '';

  switch (field.type) {
    case 'array':
      if (!field.items) {
        parsingLogic = `${fieldAccess} as List<dynamic>?`;
      } else {
        const itemType = getDartType(field.items, options, parentModelName);
        const itemFromJsonLogic = generateFromJsonLogic(field.items, options, parentModelName).replace(`data['${field.items.fieldName}']`, 'e'); // Generate item logic recursively
        const itemIsNestedClass = field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0;

        if (itemIsNestedClass) {
           // Use the nested class's fromJson factory
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => ${itemType}.fromJson(e as Map<String, dynamic>)).toList()`;
        } else if (['timestamp', 'geopoint', 'reference'].includes(field.items.type)) {
           // Handle Firestore specific types within lists
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`;
        } else if (field.items.type === 'array' || field.items.type === 'map') {
           // Basic cast for list of dynamic lists/maps (less common)
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`;
        }
        else {
           // Default cast for lists of primitives
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`;
        }
      }
      break;
    case 'map':
      if (field.properties && Object.keys(field.properties).length > 0) {
        // Use the nested class's fromJson factory
        parsingLogic = `${fieldAccess} == null ? null : ${dartType}.fromJson(${fieldAccess} as Map<String, dynamic>)`;
      } else {
        // Basic map parsing
        parsingLogic = `${fieldAccess} as ${dartType}?`;
      }
      break;
    case 'timestamp':
    case 'geopoint':
    case 'reference':
      // Direct cast for Firestore specific types
      parsingLogic = `${fieldAccess} as ${dartType}?`;
      break;
    default:
      // Default casting for primitives (String, num, bool)
      parsingLogic = `${fieldAccess} as ${dartType}?`;
      break;
  }

  // Add null check for required fields
  if (!isNullable) {
    // Make error message more generic, removing direct reference to '$data'
    parsingLogic += ` ?? (throw Exception("Missing required field: ${field.fieldName} in input data"))`;
  }
  return parsingLogic;
};

// Generates the toJson serialization logic for a field
const generateToJsonLogic = (field, options, parentModelName) => {
   let valueAccess = field.fieldName;
   switch (field.type) {
       case 'array':
           if (field.items && field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0) {
               // Array of nested objects: map over and call toJson on each item
               valueAccess = `${field.fieldName}?.map((e) => e.toJson()).toList()`;
           }
           // Primitives/other types in arrays are handled directly by Firestore
           break;
       case 'map':
           if (field.properties && Object.keys(field.properties).length > 0) {
               // Nested object: call its toJson method
               valueAccess = `${field.fieldName}?.toJson()`;
           }
           // Generic maps are handled directly
           break;
       // Primitives and Firestore types (Timestamp, GeoPoint, Reference) are handled directly
   }
   return valueAccess;
};

// --- Recursive function to generate nested classes ---
const generateClass = (className, fields, options, isNested = false) => {
  let classString = ``;
  // Generate nested classes first if this is the top-level call
  if (!isNested) {
      Object.values(fields).forEach(field => {
          if (field.type === 'map' && field.properties && Object.keys(field.properties).length > 0) {
              const nestedClassName = getNestedClassName(className, field.fieldName);
              classString += generateClass(nestedClassName, field.properties, options, true); // Recursive call
          } else if (field.type === 'array' && field.items && field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0) {
              const nestedClassName = getNestedClassName(className, field.items.fieldName || field.fieldName + 'Item'); // Use item fieldName or derive
              // Avoid duplicate generation if the same map structure is used elsewhere
              // This simple check might need refinement for complex schemas
              if (!generatedNestedClasses.has(nestedClassName)) {
                 classString += generateClass(nestedClassName, field.items.properties, options, true);
                 generatedNestedClasses.add(nestedClassName);
              }
          }
      });
  }

  // --- Start of Class Definition ---
  classString += `
/// Represents the data structure for ${isNested ? `a nested '${className}' map` : `a '${className}' document`}.
${isNested ? '' : `/// Description: ${collection.description || 'N/A'}`}
class ${className}${isNested ? '' : 'Data'} ${isNested ? 'implements ToJsonSerializable ' : ''}{
`; // Add ToJsonSerializable for nested classes

  // --- Fields ---
  Object.values(fields).forEach(field => {
    const fieldDartType = getDartType(field, options, className); // Pass current class name
    classString += `
  /// ${field.description || field.fieldName} (${field.type}${field.required ? ', required' : ''})
  final ${fieldDartType}${field.required ? '' : '?'} ${field.fieldName};
`;
  });

  // --- Constructor ---
  classString += `
  const ${className}${isNested ? '' : 'Data'}({`;
  Object.values(fields).forEach(field => {
    classString += `
    ${field.required ? 'required ' : ''}this.${field.fieldName},`;
  });
  classString += `
  })`; // End of parameter list

  // --- Add Assertions ---
  let assertionStrings = [];
  Object.values(fields).forEach(field => {
    if (field.type === 'string') {
      const isNullable = !field.required;
      const nullCheck = isNullable ? `${field.fieldName} == null || ` : '';
      let fieldAssertions = [];

      if (field.minLength != null) {
        fieldAssertions.push(`assert(${nullCheck}${field.fieldName}.length >= ${field.minLength}, '${className}.${field.fieldName} must be at least ${field.minLength} characters long')`);
      }
      if (field.maxLength != null) {
         fieldAssertions.push(`assert(${nullCheck}${field.fieldName}.length <= ${field.maxLength}, '${className}.${field.fieldName} must be at most ${field.maxLength} characters long')`);
      }
      if (field.pattern != null) {
        const dartPattern = field.pattern.replace(/\\/g, '\\\\');
        fieldAssertions.push(`assert(${nullCheck}RegExp(r'${dartPattern}').hasMatch(${field.fieldName}), '${className}.${field.fieldName} must match pattern: ${field.pattern}')`);
      }
       // Join assertions for a single field with '&&' if multiple apply (though assert takes one condition)
       // Instead, we'll add each as a separate assertion clause in the initializer list
       assertionStrings = assertionStrings.concat(fieldAssertions);
    }
    // TODO: Add assertions for number ranges (minimum, maximum) if needed
  });

  // Format assertions for Dart constructor initializer list
  if (assertionStrings.length > 0) {
     // Start with ':' for the first assertion, use ',' for subsequent ones
     classString += `\n    : ${assertionStrings.join('\n    , ')}`;
  }

  classString += `; // End of constructor
`;

  // --- fromJson Factory ---
  classString += `
  /// Creates a ${className}${isNested ? '' : 'Data'} instance from a Map.
  factory ${className}${isNested ? '' : 'Data'}.fromJson(Map<String, dynamic> data) {
    return ${className}${isNested ? '' : 'Data'}(
`;
  Object.values(fields).forEach(field => {
    const fromJsonLogic = generateFromJsonLogic(field, options, className); // Pass current class name
    classString += `
      ${field.fieldName}: ${fromJsonLogic},`;
  });
  classString += `
    );
  }
`;

  // --- fromSnapshot / fromFirestore (Only for top-level class) ---
  if (!isNested) {
    classString += `
  /// Creates a ${className}Data instance from a Firestore DocumentSnapshot.
  factory ${className}Data.fromSnapshot(DocumentSnapshot snapshot) {
    final data = snapshot.data() as Map<String, dynamic>?;
    if (data == null) {
        // Escape the $ to prevent EJS interpolation
        throw Exception("Document data was null on snapshot \${snapshot.id}!");
    }
    return ${className}Data.fromJson(data); // Reuse fromJson logic
  }

  /// Creates a ${className}Data instance from a Firestore DocumentSnapshot.
  /// Required for Firestore \`withConverter\`.
  factory ${className}Data.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
    SnapshotOptions? options,
  ) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Snapshot data was null!');
    }
    // We can reuse the existing fromJson logic.
    // data['id'] = snapshot.id; // Optional: include document ID
    return ${className}Data.fromJson(data);
  }
`;
  }

  // --- toJson Method ---
  classString += `
  /// Converts this ${className}${isNested ? '' : 'Data'} instance to a Map suitable for Firestore.
  Map<String, dynamic> toJson() {
    return {`;
  Object.values(fields).forEach(field => {
    const toJsonLogic = generateToJsonLogic(field, options, className); // Pass current class name
    classString += `
      '${field.fieldName}': ${toJsonLogic},`;
  });
  classString += `
    };
  }
`;

  // --- toFirestore (Only for top-level class) ---
  if (!isNested) {
    classString += `
  /// Converts this ${className}Data instance to a Map suitable for Firestore.
  /// Required for Firestore \`withConverter\`.
  Map<String, Object?> toFirestore(SetOptions? options) {
    // We can reuse the existing toJson logic.
    return toJson();
  }
`;
  }

  // --- copyWith Method ---
  classString += `
  /// Creates a copy of this instance with potentially modified fields.
  ${className}${isNested ? '' : 'Data'} copyWith({`;
  Object.values(fields).forEach(field => {
     const fieldDartType = getDartType(field, options, className);
     classString += `
    ${fieldDartType}? ${field.fieldName},`;
  });
  classString += `
  }) {
    return ${className}${isNested ? '' : 'Data'}(
`;
  Object.values(fields).forEach(field => {
    classString += `
      ${field.fieldName}: ${field.fieldName} ?? this.${field.fieldName},`;
  });
  classString += `
    );
  }
`;

  // --- End of Class ---
  classString += `
} // End of ${className}${isNested ? '' : 'Data'} class
`;
  return classString;
};

// Keep track of generated nested classes to avoid duplicates
const generatedNestedClasses = new Set();

_%>

<%# Generate the main class and any necessary nested classes %>
<%- generateClass(modelName, collection.fields, options) %>

<%# Removed the explicit generation here as it's now handled by generateClass() %>

  // TODO: Add toString, equals, hashCode implementations?


/// Represents the data structure for adding a new '<%- modelName %>' document.
/// Fields with default values (like server timestamps) or optional fields are nullable.
class <%- modelName %>AddData implements ToJsonSerializable {
<% Object.values(collection.fields).filter(field => !field['x-read-only']).forEach(field => { -%>
<%   const dartType = getDartType(field, options, modelName); %>
<%   // Determine if the field should be required in AddData
   // Required if: it's marked required in schema AND has no default value
   // Optional if: it's not required OR it has a default value
   const isRequiredForAdd = field.required && !field.defaultValue;
   const isOptionalForAdd = !field.required || !!field.defaultValue;
%>
  /// <%- field.description || field.fieldName %> (<%- field.type %><%- isRequiredForAdd ? ', required' : '' %>)
  final <%- dartType %><%- isOptionalForAdd ? '?' : '' %> <%- field.fieldName %>;
<% }); -%>

  const <%- modelName %>AddData({
<% Object.values(collection.fields).filter(field => !field['x-read-only']).forEach(field => { -%>
<%   const isRequiredForAdd = field.required && !field.defaultValue; %>
    <%- isRequiredForAdd ? 'required ' : '' %>this.<%- field.fieldName %>,
<% }); -%>
  });

  /// Converts this instance to a Map suitable for Firestore add operation.
  /// Excludes fields that are null to avoid overwriting server-generated values.
  @override // Indicate override of interface method
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};
<% Object.values(collection.fields).filter(field => !field['x-read-only']).forEach(field => { -%>
<%   const isOptionalForAdd = !field.required || !!field.defaultValue; %>
<%   const toJsonLogic = generateToJsonLogic(field, options, modelName); %>
<%   if (isOptionalForAdd) { -%>
    // Only include non-null values in the map for optional fields
    if (<%- field.fieldName %> != null) {
      map['<%- field.fieldName %>'] = <%- toJsonLogic %>;
    }
<%   } else { -%>
    // Required fields are always included
    map['<%- field.fieldName %>'] = <%- toJsonLogic %>;
<%   } -%>
<% }); -%>
    return map;
  }
}
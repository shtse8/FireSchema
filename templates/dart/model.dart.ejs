/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import runtime types
// Import other necessary packages if needed

<%# --- EJS Helper Functions --- %>
<% /* Standard scriptlet tag */
// Keep track of generated nested classes to avoid duplicates
const generatedNestedClasses = new Set();

// --- Type Generation ---
const getNestedClassName = (parentModelName, fieldName) => {
  return `${parentModelName}${camelToPascalCase(fieldName)}Map`;
};

const getDartType = (field, options, parentModelName) => {
  switch (field.type) {
    case 'string': return 'String';
    case 'number': return 'num';
    case 'boolean': return 'bool';
    case 'timestamp': return 'Timestamp';
    case 'geopoint': return 'GeoPoint';
    case 'reference': return `DocumentReference<Map<String, dynamic>>`;
    case 'array':
      if (!field.items) return 'List<dynamic>';
      return `List<${getDartType(field.items, options, parentModelName)}>`;
    case 'map':
      if (field.properties && Object.keys(field.properties).length > 0) {
        return getNestedClassName(parentModelName, field.fieldName);
      }
      return 'Map<String, dynamic>';
    default: return 'dynamic';
  }
};

// --- fromJson Logic Generation ---
const generateFromJsonLogic = (field, options, parentModelName) => {
  const dartType = getDartType(field, options, parentModelName);
  const isNullable = !field.required;
  const fieldAccess = `data['${field.fieldName}']`;
  let parsingLogic = '';

  switch (field.type) {
    case 'array':
      if (!field.items) {
        parsingLogic = `${fieldAccess} as List<dynamic>?`;
      } else {
        const itemType = getDartType(field.items, options, parentModelName);
        const itemIsNestedClass = field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0;

        if (itemIsNestedClass) {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => ${itemType}.fromJson(e as Map<String, dynamic>)).toList()`;
        } else if (['timestamp', 'geopoint', 'reference'].includes(field.items.type)) {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`;
        } else if (field.items.type === 'array' || field.items.type === 'map') {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`;
        } else {
           parsingLogic = `(${fieldAccess} as List<dynamic>?)?.map((e) => e as ${itemType}).toList()`;
        }
      }
      break;
    case 'map':
      if (field.properties && Object.keys(field.properties).length > 0) {
        parsingLogic = `${fieldAccess} == null ? null : ${dartType}.fromJson(${fieldAccess} as Map<String, dynamic>)`;
      } else {
        parsingLogic = `${fieldAccess} as ${dartType}?`;
      }
      break;
    case 'timestamp':
    case 'geopoint':
    case 'reference':
      parsingLogic = `${fieldAccess} as ${dartType}?`;
      break;
    default: // string, number, bool, dynamic
      parsingLogic = `${fieldAccess} as ${dartType}?`;
      break;
  }

  if (!isNullable) {
    parsingLogic += ` ?? (throw Exception("Missing required field: ${field.fieldName} in input data"))`;
  }
  return parsingLogic;
};

// --- toJson Logic Generation ---
const generateToJsonLogic = (field, options, parentModelName) => {
   let valueAccess = field.fieldName;
   switch (field.type) {
       case 'array':
           if (field.items && field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0) {
               valueAccess = `${field.fieldName}?.map((e) => e.toJson()).toList()`;
           }
           break;
       case 'map':
           if (field.properties && Object.keys(field.properties).length > 0) {
               valueAccess = `${field.fieldName}?.toJson()`;
           }
           break;
   }
   return valueAccess;
};

// --- Assertion Generation ---
const generateAssertionBodyStrings = (className, fields) => {
  let assertionStrings = [];
  Object.values(fields).forEach(field => {
    const isNullable = !field.required;
    const nullCheck = isNullable ? `(${field.fieldName} == null || ` : '';
    const closeNullCheck = isNullable ? ')' : '';

    if (field.type === 'string') {
      if (field.minLength != null) {
        assertionStrings.push(`assert(${nullCheck}${field.fieldName}.length >= ${field.minLength}${closeNullCheck}, '${className}.${field.fieldName} must be at least ${field.minLength} characters long');`);
      }
      if (field.maxLength != null) {
         assertionStrings.push(`assert(${nullCheck}${field.fieldName}.length <= ${field.maxLength}${closeNullCheck}, '${className}.${field.fieldName} must be at most ${field.maxLength} characters long');`);
      }
      if (field.pattern != null) {
        const dartPattern = field.pattern.replace(/\\/g, '\\\\');
        assertionStrings.push(`assert(${nullCheck}RegExp(r'${dartPattern}').hasMatch(${field.fieldName})${closeNullCheck}, '${className}.${field.fieldName} must match pattern: ${field.pattern}');`);
      }
    } else if (field.type === 'number') {
      if (field.minimum != null) {
        assertionStrings.push(`assert(${nullCheck}${field.fieldName} >= ${field.minimum}${closeNullCheck}, '${className}.${field.fieldName} must be >= ${field.minimum}');`);
      }
      if (field.maximum != null) {
        assertionStrings.push(`assert(${nullCheck}${field.fieldName} <= ${field.maximum}${closeNullCheck}, '${className}.${field.fieldName} must be <= ${field.maximum}');`);
      }
    }
  });
  return assertionStrings;
};


// --- Main Class Data Preparation Function ---
const prepareClassData = (className, fields, options, isNested = false, collectionDescription = null) => {
  const classData = {
      className: className,
      isNested: isNested,
      collectionDescription: collectionDescription,
      fields: fields,
      options: options,
      implementsToJson: isNested ? 'implements ToJsonSerializable ' : '',
      dataSuffix: isNested ? '' : 'Data',
      fieldStrings: Object.values(fields).map(field => {
          const fieldDartType = getDartType(field, options, className);
          return `  /// ${field.description || field.fieldName} (${field.type}${field.required ? ', required' : ''})\n  final ${fieldDartType}${field.required ? '' : '?'} ${field.fieldName};`;
      }).join('\n'),
      constructorParams: Object.values(fields).map(field => `    ${field.required ? 'required ' : ''}this.${field.fieldName},`).join('\n'),
      assertions: generateAssertionBodyStrings(className, fields),
      fromJsonParams: Object.values(fields).map(field => `      ${field.fieldName}: ${generateFromJsonLogic(field, options, className)},`).join('\n'),
      toJsonEntries: Object.values(fields).map(field => `      '${field.fieldName}': ${generateToJsonLogic(field, options, className)},`).join('\n'),
      copyWithParams: Object.values(fields).map(field => `    ${getDartType(field, options, className)}? ${field.fieldName},`).join('\n'),
      copyWithBody: Object.values(fields).map(field => `      ${field.fieldName}: ${field.fieldName} ?? this.${field.fieldName},`).join('\n'),
  };
  return classData;
};

// --- AddData Class Generation ---
const prepareAddData = (modelName, fields, options) => {
    const addFields = Object.values(fields).filter(field => !field['x-read-only']);
    const fieldStrings = addFields.map(field => {
        const dartType = getDartType(field, options, modelName);
        const isOptionalForAdd = !field.required || !!field.defaultValue;
        return `  /// ${field.description || field.fieldName} (${field.type}${field.required && !field.defaultValue ? ', required' : ''})\n  final ${dartType}${isOptionalForAdd ? '?' : ''} ${field.fieldName};`;
    }).join('\n');

    const constructorParams = addFields.map(field => {
        const isRequiredForAdd = field.required && !field.defaultValue;
        return `    ${isRequiredForAdd ? 'required ' : ''}this.${field.fieldName},`;
    }).join('\n');

    const toJsonEntries = addFields.map(field => {
        const isOptionalForAdd = !field.required || !!field.defaultValue;
        const toJsonLogic = generateToJsonLogic(field, options, modelName);
        if (isOptionalForAdd) {
            return `    if (${field.fieldName} != null) {\n      map['${field.fieldName}'] = ${toJsonLogic};\n    }`;
        } else {
            return `    map['${field.fieldName}'] = ${toJsonLogic};`;
        }
    }).join('\n');

    return { modelName, fieldStrings, constructorParams, toJsonEntries };
};

// --- UpdateData Class Generation ---
const prepareUpdateData = (modelName, fields, options) => {
    const updateFields = Object.values(fields).filter(field => !field['x-read-only']);
    const fieldStrings = updateFields.map(field => {
        const dartType = getDartType(field, options, modelName);
        return `  /// ${field.description || field.fieldName} (${field.type})\n  final ${dartType}? ${field.fieldName};`;
    }).join('\n');

    const constructorParams = updateFields.map(field => `    this.${field.fieldName},`).join('\n');

    const toJsonEntries = updateFields.map(field => {
        const toJsonLogic = generateToJsonLogic(field, options, modelName);
        return `    if (${field.fieldName} != null) {\n      map['${field.fieldName}'] = ${toJsonLogic};\n    }`;
    }).join('\n');

    return { modelName, fieldStrings, constructorParams, toJsonEntries };
};

// --- Recursive generation for nested classes ---
const generateNestedClasses = (className, fields, options) => {
  let nestedClassesString = '';
  Object.values(fields).forEach(field => {
      if (field.type === 'map' && field.properties && Object.keys(field.properties).length > 0) {
          const nestedClassName = getNestedClassName(className, field.fieldName);
          nestedClassesString += generateSingleClass(nestedClassName, field.properties, options, true); // Recursive call
      } else if (field.type === 'array' && field.items && field.items.type === 'map' && field.items.properties && Object.keys(field.items.properties).length > 0) {
          const nestedClassName = getNestedClassName(className, field.items.fieldName || field.fieldName + 'Item');
          if (!generatedNestedClasses.has(nestedClassName)) {
             nestedClassesString += generateSingleClass(nestedClassName, field.items.properties, options, true);
             generatedNestedClasses.add(nestedClassName);
          }
      }
  });
  return nestedClassesString;
};

// --- Generates a single class using the template ---
const generateSingleClass = (className, fields, options, isNested = false, collectionDescription = null) => {
    const classData = prepareClassData(className, fields, options, isNested, collectionDescription);
    // Define the template string for a single class, escaping inner EJS tags
    // Simplified inner template content for diagnostics
    const template = `
/// Represents the data structure for <%%- isNested ? 'a nested map' : 'a document' %%>.
class <%%- className %%><%%- dataSuffix %%> <%%- implementsToJson %%>{
  // Simplified content for diagnostics
  <%%- className %%><%%- dataSuffix %%>();
  factory <%%- className %%><%%- dataSuffix %%>.fromJson(Map<String, dynamic> data) => <%%- className %%><%%- dataSuffix %%>();
  Map<String, dynamic> toJson() => {};
<%%% if (!isNested) { %%%>
  factory <%%- className %%>Data.fromSnapshot(DocumentSnapshot snapshot) => <%%- className %%>Data();
  factory <%%- className %%>Data.fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot, SnapshotOptions? options) => <%%- className %%>Data();
  Map<String, Object?> toFirestore(SetOptions? options) => toJson();
<%%% } %%%>
  <%%- className %%><%%- dataSuffix %%> copyWith() => this;
}
`;
    // Render the inner template string
    return ejs.render(template, classData); // Re-enabled nested render
};
%> <%# End of main scriptlet block %>

<%# --- Template Output --- %>
<%# Generate nested classes first %>
<%- generateNestedClasses(modelName, collection.fields, options) %>

<%# Generate the main class %>
<%- generateSingleClass(modelName, collection.fields, options, false, collection.description) %>

<%# Generate AddData class %>
<% const addData = prepareAddData(modelName, collection.fields, options); %>
/// Represents the data structure for adding a new '<%- addData.modelName %>' document.
/// Fields with default values (like server timestamps) or optional fields are nullable.
class <%- addData.modelName %>AddData implements ToJsonSerializable {
<%- addData.fieldStrings %>

  const <%- addData.modelName %>AddData({
<%- addData.constructorParams %>
  });

  /// Converts this instance to a Map suitable for Firestore add operation.
  /// Excludes fields that are null to avoid overwriting server-generated values.
  @override // Indicate override of interface method
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};
<%- addData.toJsonEntries %>
    return map;
  }
}

<%# Generate UpdateData class %>
<% const updateData = prepareUpdateData(modelName, collection.fields, options); %>
/// Represents the data structure for updating an existing '<%- updateData.modelName %>' document.
/// All fields are optional, allowing for partial updates.
class <%- updateData.modelName %>UpdateData implements ToJsonSerializable {
<%- updateData.fieldStrings %>

  <%- updateData.modelName %>UpdateData({ // Not const
<%- updateData.constructorParams %>
  });

  /// Converts this instance to a Map suitable for Firestore update operation.
  /// Only includes fields that are not null.
  @override // Indicate override of interface method
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};
<%- updateData.toJsonEntries %>
    return map;
  }
}
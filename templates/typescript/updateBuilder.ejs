/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  DocumentReference,
  updateDoc,
  FieldValue,
  serverTimestamp,
  increment,
  arrayUnion,
  arrayRemove,
  deleteField,
} from 'firebase/firestore';
import { <%- modelName %>Data } from './<%- collection.collectionId %>.types';

// Define the structure for update data, allowing FieldValue types
// This is complex to type perfectly for nested fields, so internal representation is simpler.
// type FieldValueUpdate<T> = {
//   [K in keyof T]?: T[K] | FieldValue;
// };

/**
 * A typed builder for creating update operations for '<%- collection.collectionId %>' documents.
 */
export class <%- modelName %>UpdateBuilder {
  private _docRef: DocumentReference<<%- modelName %>Data>;
  private _updateData: Record<string, any> = {}; // Use Record<string, any> internally

  constructor(docRef: DocumentReference<<%- modelName %>Data>) {
    this._docRef = docRef;
  }

  // --- Field Setters ---
<% Object.values(collection.fields).forEach(field => { -%>
<%   const fieldType = getTypeScriptType(field, options); -%>
  /** Sets the value for the '<%- field.fieldName %>' field. */
  set<%- capitalizeFirstLetter(field.fieldName) %>(value: <%- fieldType %>): this {
    this._updateData['<%- field.fieldName %>'] = value;
    return this;
  }

<%   // --- Atomic Operations --- -%>
<%   if (field.type === 'number') { -%>
  /** Atomically increments the '<%- field.fieldName %>' field. */
  increment<%- capitalizeFirstLetter(field.fieldName) %>(value: number): this {
    this._updateData['<%- field.fieldName %>'] = increment(value);
    return this;
  }
<%   } -%>
<%   if (field.type === 'array') { -%>
<%     const itemType = field.items ? getTypeScriptType(field.items, options) : 'any'; -%>
  /** Atomically adds elements to the '<%- field.fieldName %>' array field. */
  arrayUnion<%- capitalizeFirstLetter(field.fieldName) %>(values: <%- itemType %>[] | <%- itemType %>): this {
    this._updateData['<%- field.fieldName %>'] = arrayUnion(...(Array.isArray(values) ? values : [values]));
    return this;
  }

  /** Atomically removes elements from the '<%- field.fieldName %>' array field. */
  arrayRemove<%- capitalizeFirstLetter(field.fieldName) %>(values: <%- itemType %>[] | <%- itemType %>): this {
    this._updateData['<%- field.fieldName %>'] = arrayRemove(...(Array.isArray(values) ? values : [values]));
    return this;
  }
<%   } -%>
<%   if (field.type === 'timestamp' && field.defaultValue === 'serverTimestamp') { -%>
  /** Sets the '<%- field.fieldName %>' field to the server timestamp. */
  set<%- capitalizeFirstLetter(field.fieldName) %>ToServerTimestamp(): this {
    this._updateData['<%- field.fieldName %>'] = serverTimestamp();
    return this;
  }
<%   } -%>
<%   if (!field.required) { -%>
  /** Deletes the '<%- field.fieldName %>' field. */
  delete<%- capitalizeFirstLetter(field.fieldName) %>(): this {
    this._updateData['<%- field.fieldName %>'] = deleteField();
    return this;
  }
<%   } -%>

<% }); -%>
  // --- End Field Setters ---

  /**
   * Commits the update operations to Firestore.
   * @returns A promise that resolves when the update is complete.
   */
  async commit(): Promise<void> {
    if (Object.keys(this._updateData).length === 0) {
      // No updates specified, maybe warn or just do nothing?
      console.warn('Update commit called with no changes specified.');
      return;
    }
    await updateDoc(this._docRef, this._updateData);
  }
}
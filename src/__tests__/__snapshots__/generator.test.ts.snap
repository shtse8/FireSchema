// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`FireSchema Generator should generate Dart files matching snapshots: items_collection.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import 'package:cloud_firestore/cloud_firestore.dart';
// Runtime Imports
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import the runtime package

// Local Imports
import 'items_data.dart';
import 'items_query.dart';
import 'items_update.dart';





import './items/tags_collection.dart'; // Import subcollection class
import './items/tags_data.dart'; // Import subcollection data class



/// Typed reference to the 'items' collection, extending BaseCollectionRef.
class ItemsCollection extends BaseCollectionRef<ItemsData, ItemsAddData> { // Use the specific AddData type

  /// Creates a ItemsCollection instance.
  ItemsCollection({
    required FirebaseFirestore firestore,
    DocumentReference? parentRef, // Optional parent ref
  }) : super(
          firestore: firestore,
          collectionId: 'items',
          parentRef: parentRef,
          // Provide the fromFirestore and toFirestore converters specific to ItemsData
          fromFirestore: ItemsData.fromFirestore,
          toFirestore: (data, options) => data.toFirestore(options),
          // Pass schema details if needed by base class features (like defaults)
          schema: const { // Example schema structure - adjust if BaseCollectionRef uses it differently
            'fields': {
              'name': { 'defaultValue': null },
              'value': { 'defaultValue': null },
              'createdAt': { 'defaultValue': "serverTimestamp" },
              'address': { 'defaultValue': null },
            },
          },
        );

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /// Creates a new ItemsQueryBuilder instance for this collection.
  ItemsQueryBuilder query() {
    // Returns the specific generated QueryBuilder
    return ItemsQueryBuilder(
      firestore: firestore, // Pass firestore instance
      collectionRef: ref, // Pass the typed collection reference
    );
  }

  /// Creates a new ItemsUpdateBuilder instance for the document with the given ID.
  ItemsUpdateBuilder update(String id) {
    // Returns the specific generated UpdateBuilder
    return ItemsUpdateBuilder(docRef: doc(id)); // Pass the typed document reference
  }

  // --- Subcollection Accessors ---




  /// Access the 'tags' subcollection for a specific document.
  TagsCollection tags(String documentId) {
    // Use the helper method from BaseCollectionRef
    // Need to define the factory function for the subcollection class
    // Call subCollection helper with positional arguments
    return subCollection(
      documentId, // parentId
      'tags', // subCollectionId
      // subCollectionFactory (factory function)
      // subCollectionFactory (Simplified signature matching the updated BaseCollectionRef helper)
      ({
        required FirebaseFirestore firestore,
        required String collectionId,
        CollectionSchema? schema,
        required DocumentReference? parentRef,
      }) => TagsCollection(firestore: firestore, parentRef: parentRef),
      // subFromFirestore (Use the correct sub-model name)
      TagsData.fromFirestore,
      // subToFirestore
      (data, options) => (data as TagsData).toFirestore(options),
      // subSchema (optional)
      const { // Construct the schema object for the subcollection
        'fields': {
          'label': { 'defaultValue': null },
        },
      },
    );
  }



  // --- Custom Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: items_data.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import runtime types
// Import other necessary packages if needed





/// Represents the data structure for a nested 'ItemsAddressMap' map.

class ItemsAddressMap implements ToJsonSerializable {

  /// street (string, required)
  final String street;

  /// city (string, required)
  final String city;

  /// zip (string)
  final String? zip;

  /// coords (map)
  final ItemsAddressMapCoordsMap? coords;

  const ItemsAddressMap({
    required this.street,
    required this.city,
    this.zip,
    this.coords,
  });

  /// Creates a ItemsAddressMap instance from a Map.
  factory ItemsAddressMap.fromJson(Map<String, dynamic> data) {
    return ItemsAddressMap(

      street: data['street'] as String? ?? (throw Exception("Missing required field: street in input data")),
      city: data['city'] as String? ?? (throw Exception("Missing required field: city in input data")),
      zip: data['zip'] as String?,
      coords: data['coords'] == null ? null : ItemsAddressMapCoordsMap.fromJson(data['coords'] as Map<String, dynamic>),
    );
  }

  /// Converts this ItemsAddressMap instance to a Map suitable for Firestore.
  Map<String, dynamic> toJson() {
    return {
      'street': street,
      'city': city,
      'zip': zip,
      'coords': coords?.toJson(),
    };
  }

  /// Creates a copy of this instance with potentially modified fields.
  ItemsAddressMap copyWith({
    String? street,
    String? city,
    String? zip,
    ItemsAddressMapCoordsMap? coords,
  }) {
    return ItemsAddressMap(

      street: street ?? this.street,
      city: city ?? this.city,
      zip: zip ?? this.zip,
      coords: coords ?? this.coords,
    );
  }

} // End of ItemsAddressMap class

/// Represents the data structure for a 'Items' document.
/// Description: A collection of test items.
class ItemsData {

  /// name (string, required)
  final String name;

  /// value (number)
  final num? value;

  /// createdAt (timestamp, required)
  final Timestamp createdAt;

  /// address (map)
  final ItemsAddressMap? address;

  const ItemsData({
    required this.name,
    this.value,
    required this.createdAt,
    this.address,
  });

  /// Creates a ItemsData instance from a Map.
  factory ItemsData.fromJson(Map<String, dynamic> data) {
    return ItemsData(

      name: data['name'] as String? ?? (throw Exception("Missing required field: name in input data")),
      value: data['value'] as num?,
      createdAt: data['createdAt'] as Timestamp? ?? (throw Exception("Missing required field: createdAt in input data")),
      address: data['address'] == null ? null : ItemsAddressMap.fromJson(data['address'] as Map<String, dynamic>),
    );
  }

  /// Creates a ItemsData instance from a Firestore DocumentSnapshot.
  factory ItemsData.fromSnapshot(DocumentSnapshot snapshot) {
    final data = snapshot.data() as Map<String, dynamic>?;
    if (data == null) {
        // Escape the $ to prevent EJS interpolation
        throw Exception("Document data was null on snapshot \${snapshot.id}!");
    }
    return ItemsData.fromJson(data); // Reuse fromJson logic
  }

  /// Creates a ItemsData instance from a Firestore DocumentSnapshot.
  /// Required for Firestore \`withConverter\`.
  factory ItemsData.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
    SnapshotOptions? options,
  ) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Snapshot data was null!');
    }
    // We can reuse the existing fromJson logic.
    // data['id'] = snapshot.id; // Optional: include document ID
    return ItemsData.fromJson(data);
  }

  /// Converts this ItemsData instance to a Map suitable for Firestore.
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'value': value,
      'createdAt': createdAt,
      'address': address?.toJson(),
    };
  }

  /// Converts this ItemsData instance to a Map suitable for Firestore.
  /// Required for Firestore \`withConverter\`.
  Map<String, Object?> toFirestore(SetOptions? options) {
    // We can reuse the existing toJson logic.
    return toJson();
  }

  /// Creates a copy of this instance with potentially modified fields.
  ItemsData copyWith({
    String? name,
    num? value,
    Timestamp? createdAt,
    ItemsAddressMap? address,
  }) {
    return ItemsData(

      name: name ?? this.name,
      value: value ?? this.value,
      createdAt: createdAt ?? this.createdAt,
      address: address ?? this.address,
    );
  }

} // End of ItemsData class




  // TODO: Add toString, equals, hashCode implementations?


/// Represents the data structure for adding a new 'Items' document.
/// Fields with default values (like server timestamps) or optional fields are nullable.
class ItemsAddData implements ToJsonSerializable {


  /// name (string, required)
  final String name;


  /// value (number)
  final num? value;


  /// createdAt (timestamp)
  final Timestamp? createdAt;


  /// address (map)
  final ItemsAddressMap? address;

  const ItemsAddData({

    required this.name,

    this.value,

    this.createdAt,

    this.address,
  });

  /// Converts this instance to a Map suitable for Firestore add operation.
  /// Excludes fields that are null to avoid overwriting server-generated values.
  @override // Indicate override of interface method
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};


    // Required fields are always included
    map['name'] = name;


    // Only include non-null values in the map for optional fields
    if (value != null) {
      map['value'] = value;
    }


    // Only include non-null values in the map for optional fields
    if (createdAt != null) {
      map['createdAt'] = createdAt;
    }


    // Only include non-null values in the map for optional fields
    if (address != null) {
      map['address'] = address?.toJson();
    }
    return map;
  }
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: items_query.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import 'package:cloud_firestore/cloud_firestore.dart';
// Runtime Imports
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import the runtime package

// Local Imports
import 'items_data.dart';

/// A typed query builder for the 'items' collection, extending BaseQueryBuilder.
class ItemsQueryBuilder extends BaseQueryBuilder<ItemsData> {

  /// Creates a ItemsQueryBuilder instance.
  ItemsQueryBuilder({
    required FirebaseFirestore firestore,
    required CollectionReference<ItemsData> collectionRef,
  }) : super(firestore: firestore, collectionRef: collectionRef);

  // Constructor and internal query state are inherited from BaseQueryBuilder

  // --- Field-specific Where Methods ---
  /// Adds a query filter for the 'name' field.
  /// Provide one of the named parameters to specify the query condition.
  ItemsQueryBuilder whereName({
    String? isEqualTo, // Ensure only one trailing '?' for nullable parameter
    String? isNotEqualTo, // Ensure only one trailing '?' for nullable parameter
    String? isLessThan, // Ensure only one trailing '?' for nullable parameter
    String? isLessThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    String? isGreaterThan, // Ensure only one trailing '?' for nullable parameter
    String? isGreaterThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereIn, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereNotIn, // Ensure only one trailing '?' for nullable parameter
  }) {
    // Call the protected where method from the base class
    return where(
      'name', // Pass the field path string
      isEqualTo: isEqualTo,
      isNotEqualTo: isNotEqualTo,
      isLessThan: isLessThan,
      isLessThanOrEqualTo: isLessThanOrEqualTo,
      isGreaterThan: isGreaterThan,
      isGreaterThanOrEqualTo: isGreaterThanOrEqualTo,
      whereIn: whereIn,
      whereNotIn: whereNotIn,
    ) as ItemsQueryBuilder; // Cast back to specific type is necessary
  }
  /// Adds a query filter for the 'value' field.
  /// Provide one of the named parameters to specify the query condition.
  ItemsQueryBuilder whereValue({
    num? isEqualTo, // Ensure only one trailing '?' for nullable parameter
    num? isNotEqualTo, // Ensure only one trailing '?' for nullable parameter
    num? isLessThan, // Ensure only one trailing '?' for nullable parameter
    num? isLessThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    num? isGreaterThan, // Ensure only one trailing '?' for nullable parameter
    num? isGreaterThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereIn, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereNotIn, // Ensure only one trailing '?' for nullable parameter
  }) {
    // Call the protected where method from the base class
    return where(
      'value', // Pass the field path string
      isEqualTo: isEqualTo,
      isNotEqualTo: isNotEqualTo,
      isLessThan: isLessThan,
      isLessThanOrEqualTo: isLessThanOrEqualTo,
      isGreaterThan: isGreaterThan,
      isGreaterThanOrEqualTo: isGreaterThanOrEqualTo,
      whereIn: whereIn,
      whereNotIn: whereNotIn,
    ) as ItemsQueryBuilder; // Cast back to specific type is necessary
  }
  /// Adds a query filter for the 'createdAt' field.
  /// Provide one of the named parameters to specify the query condition.
  ItemsQueryBuilder whereCreatedAt({
    Timestamp? isEqualTo, // Ensure only one trailing '?' for nullable parameter
    Timestamp? isNotEqualTo, // Ensure only one trailing '?' for nullable parameter
    Timestamp? isLessThan, // Ensure only one trailing '?' for nullable parameter
    Timestamp? isLessThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    Timestamp? isGreaterThan, // Ensure only one trailing '?' for nullable parameter
    Timestamp? isGreaterThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereIn, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereNotIn, // Ensure only one trailing '?' for nullable parameter
  }) {
    // Call the protected where method from the base class
    return where(
      'createdAt', // Pass the field path string
      isEqualTo: isEqualTo,
      isNotEqualTo: isNotEqualTo,
      isLessThan: isLessThan,
      isLessThanOrEqualTo: isLessThanOrEqualTo,
      isGreaterThan: isGreaterThan,
      isGreaterThanOrEqualTo: isGreaterThanOrEqualTo,
      whereIn: whereIn,
      whereNotIn: whereNotIn,
    ) as ItemsQueryBuilder; // Cast back to specific type is necessary
  }
  /// Adds a query filter for the 'address' field.
  /// Provide one of the named parameters to specify the query condition.
  ItemsQueryBuilder whereAddress({
    Map<String, dynamic>? isEqualTo, // Ensure only one trailing '?' for nullable parameter
    Map<String, dynamic>? isNotEqualTo, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereIn, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereNotIn, // Ensure only one trailing '?' for nullable parameter
  }) {
    // Call the protected where method from the base class
    return where(
      'address', // Pass the field path string
      isEqualTo: isEqualTo,
      isNotEqualTo: isNotEqualTo,
      whereIn: whereIn,
      whereNotIn: whereNotIn,
    ) as ItemsQueryBuilder; // Cast back to specific type is necessary
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getData() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: items_tags_collection.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import 'package:cloud_firestore/cloud_firestore.dart';
// Runtime Imports
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import the runtime package

// Local Imports
import 'tags_data.dart';
import 'tags_query.dart';
import 'tags_update.dart';



/// Typed reference to the 'tags' collection, extending BaseCollectionRef.
class TagsCollection extends BaseCollectionRef<TagsData, TagsAddData> { // Use the specific AddData type

  /// Creates a TagsCollection instance.
  TagsCollection({
    required FirebaseFirestore firestore,
    DocumentReference? parentRef, // Optional parent ref
  }) : super(
          firestore: firestore,
          collectionId: 'tags',
          parentRef: parentRef,
          // Provide the fromFirestore and toFirestore converters specific to TagsData
          fromFirestore: TagsData.fromFirestore,
          toFirestore: (data, options) => data.toFirestore(options),
          // Pass schema details if needed by base class features (like defaults)
          schema: const { // Example schema structure - adjust if BaseCollectionRef uses it differently
            'fields': {
              'label': { 'defaultValue': null },
            },
          },
        );

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /// Creates a new TagsQueryBuilder instance for this collection.
  TagsQueryBuilder query() {
    // Returns the specific generated QueryBuilder
    return TagsQueryBuilder(
      firestore: firestore, // Pass firestore instance
      collectionRef: ref, // Pass the typed collection reference
    );
  }

  /// Creates a new TagsUpdateBuilder instance for the document with the given ID.
  TagsUpdateBuilder update(String id) {
    // Returns the specific generated UpdateBuilder
    return TagsUpdateBuilder(docRef: doc(id)); // Pass the typed document reference
  }

  // --- Subcollection Accessors ---


  // --- Custom Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: items_tags_data.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
// ignore_for_file: unused_import, unused_local_variable

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import runtime types
// Import other necessary packages if needed





/// Represents the data structure for a 'Tags' document.
/// Description: Tags for an item.
class TagsData {

  /// label (string, required)
  final String label;

  const TagsData({
    required this.label,
  });

  /// Creates a TagsData instance from a Map.
  factory TagsData.fromJson(Map<String, dynamic> data) {
    return TagsData(

      label: data['label'] as String? ?? (throw Exception("Missing required field: label in input data")),
    );
  }

  /// Creates a TagsData instance from a Firestore DocumentSnapshot.
  factory TagsData.fromSnapshot(DocumentSnapshot snapshot) {
    final data = snapshot.data() as Map<String, dynamic>?;
    if (data == null) {
        // Escape the $ to prevent EJS interpolation
        throw Exception("Document data was null on snapshot \${snapshot.id}!");
    }
    return TagsData.fromJson(data); // Reuse fromJson logic
  }

  /// Creates a TagsData instance from a Firestore DocumentSnapshot.
  /// Required for Firestore \`withConverter\`.
  factory TagsData.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
    SnapshotOptions? options,
  ) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Snapshot data was null!');
    }
    // We can reuse the existing fromJson logic.
    // data['id'] = snapshot.id; // Optional: include document ID
    return TagsData.fromJson(data);
  }

  /// Converts this TagsData instance to a Map suitable for Firestore.
  Map<String, dynamic> toJson() {
    return {
      'label': label,
    };
  }

  /// Converts this TagsData instance to a Map suitable for Firestore.
  /// Required for Firestore \`withConverter\`.
  Map<String, Object?> toFirestore(SetOptions? options) {
    // We can reuse the existing toJson logic.
    return toJson();
  }

  /// Creates a copy of this instance with potentially modified fields.
  TagsData copyWith({
    String? label,
  }) {
    return TagsData(

      label: label ?? this.label,
    );
  }

} // End of TagsData class




  // TODO: Add toString, equals, hashCode implementations?


/// Represents the data structure for adding a new 'Tags' document.
/// Fields with default values (like server timestamps) or optional fields are nullable.
class TagsAddData implements ToJsonSerializable {


  /// label (string, required)
  final String label;

  const TagsAddData({

    required this.label,
  });

  /// Converts this instance to a Map suitable for Firestore add operation.
  /// Excludes fields that are null to avoid overwriting server-generated values.
  @override // Indicate override of interface method
  Map<String, Object?> toJson() {
    final map = <String, Object?>{};


    // Required fields are always included
    map['label'] = label;
    return map;
  }
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: items_tags_query.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import 'package:cloud_firestore/cloud_firestore.dart';
// Runtime Imports
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import the runtime package

// Local Imports
import 'tags_data.dart';

/// A typed query builder for the 'tags' collection, extending BaseQueryBuilder.
class TagsQueryBuilder extends BaseQueryBuilder<TagsData> {

  /// Creates a TagsQueryBuilder instance.
  TagsQueryBuilder({
    required FirebaseFirestore firestore,
    required CollectionReference<TagsData> collectionRef,
  }) : super(firestore: firestore, collectionRef: collectionRef);

  // Constructor and internal query state are inherited from BaseQueryBuilder

  // --- Field-specific Where Methods ---
  /// Adds a query filter for the 'label' field.
  /// Provide one of the named parameters to specify the query condition.
  TagsQueryBuilder whereLabel({
    String? isEqualTo, // Ensure only one trailing '?' for nullable parameter
    String? isNotEqualTo, // Ensure only one trailing '?' for nullable parameter
    String? isLessThan, // Ensure only one trailing '?' for nullable parameter
    String? isLessThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    String? isGreaterThan, // Ensure only one trailing '?' for nullable parameter
    String? isGreaterThanOrEqualTo, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereIn, // Ensure only one trailing '?' for nullable parameter
    List<dynamic>? whereNotIn, // Ensure only one trailing '?' for nullable parameter
  }) {
    // Call the protected where method from the base class
    return where(
      'label', // Pass the field path string
      isEqualTo: isEqualTo,
      isNotEqualTo: isNotEqualTo,
      isLessThan: isLessThan,
      isLessThanOrEqualTo: isLessThanOrEqualTo,
      isGreaterThan: isGreaterThan,
      isGreaterThanOrEqualTo: isGreaterThanOrEqualTo,
      whereIn: whereIn,
      whereNotIn: whereNotIn,
    ) as TagsQueryBuilder; // Cast back to specific type is necessary
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getData() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: items_tags_update.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import 'package:cloud_firestore/cloud_firestore.dart';
// Runtime Imports
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import the runtime package

// Local Imports
import 'tags_data.dart';

/// A typed builder for creating update operations for 'tags' documents, extending BaseUpdateBuilder.
class TagsUpdateBuilder extends BaseUpdateBuilder<TagsData> {

  /// Creates a TagsUpdateBuilder instance.
  TagsUpdateBuilder({required DocumentReference<TagsData> docRef})
      : super(docRef: docRef);

  // Constructor and internal updateData map are inherited from BaseUpdateBuilder

  // --- Field Setters ---
  /// Sets the value for the 'label' field.
  TagsUpdateBuilder setLabel(String value) {
    // Call the protected set method from the base class
    return set('label', value) as TagsUpdateBuilder; // Cast back
  }


  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: items_update.dart 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import 'package:cloud_firestore/cloud_firestore.dart';
// Runtime Imports
import 'package:fireschema_dart_runtime/fireschema_dart_runtime.dart'; // Import the runtime package

// Local Imports
import 'items_data.dart';

/// A typed builder for creating update operations for 'items' documents, extending BaseUpdateBuilder.
class ItemsUpdateBuilder extends BaseUpdateBuilder<ItemsData> {

  /// Creates a ItemsUpdateBuilder instance.
  ItemsUpdateBuilder({required DocumentReference<ItemsData> docRef})
      : super(docRef: docRef);

  // Constructor and internal updateData map are inherited from BaseUpdateBuilder

  // --- Field Setters ---
  /// Sets the value for the 'name' field.
  ItemsUpdateBuilder setName(String value) {
    // Call the protected set method from the base class
    return set('name', value) as ItemsUpdateBuilder; // Cast back
  }


  /// Sets the value for the 'value' field.
  ItemsUpdateBuilder setValue(num? value) {
    // Call the protected set method from the base class
    return set('value', value) as ItemsUpdateBuilder; // Cast back
  }

  /// Atomically increments the 'value' field by the given value.
  ItemsUpdateBuilder incrementValue(num value) {
    // Call the protected increment helper
    return increment('value', value) as ItemsUpdateBuilder; // Cast back
  }
  /// Deletes the 'value' field.
  ItemsUpdateBuilder deleteValue() {
    // Call the protected deleteField helper
    return deleteField('value') as ItemsUpdateBuilder; // Cast back
  }

  /// Sets the value for the 'createdAt' field.
  ItemsUpdateBuilder setCreatedAt(Timestamp value) {
    // Call the protected set method from the base class
    return set('createdAt', value) as ItemsUpdateBuilder; // Cast back
  }

  /// Sets the 'createdAt' field to the server timestamp.
  ItemsUpdateBuilder setCreatedAtToServerTimestamp() {
    // Call the protected serverTimestamp helper
    return serverTimestamp('createdAt') as ItemsUpdateBuilder; // Cast back
  }

  /// Sets the value for the 'address' field.
  ItemsUpdateBuilder setAddress(Map<String, dynamic>? value) {
    // Call the protected set method from the base class
    return set('address', value) as ItemsUpdateBuilder; // Cast back
  }

  /// Deletes the 'address' field.
  ItemsUpdateBuilder deleteAddress() {
    // Call the protected deleteField helper
    return deleteField('address') as ItemsUpdateBuilder; // Cast back
  }

  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate Dart files matching snapshots: pubspec.yaml 1`] = `
"name: test_generated_dart
description: Test Dart generated code
version: 1.0.0
publish_to: none # Prevent accidental publishing with path dependencies
# repository: # Optional: Add repository URL if available

environment:
  sdk: '>=2.17.0 <4.0.0' # Example SDK constraint, adjust as needed
  flutter: '>=1.17.0' # Optional: if primarily for Flutter

dependencies:
  flutter: # Optional: if primarily for Flutter
    sdk: flutter
  cloud_firestore: ^4.0.0 # Example version constraint, adjust as needed
  fireschema_dart_runtime:
    path: ../packages/fireschema_dart_runtime # Use path relative to project root
  # Add other necessary dependencies if the generated code requires them

dev_dependencies:
  flutter_test: # Optional: if primarily for Flutter
    sdk: flutter
  flutter_lints: ^2.0.0 # Example linter

# For information on the generic Dart part of this file, see
# https://dart.dev/tools/pub/pubspec
"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items.collection.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as AdminFirestore, DocumentReference as AdminDocumentReference, DocumentData as AdminDocumentData } from 'firebase-admin/firestore';

// Runtime Imports - Base class and generic types
import { BaseCollectionRef } from '@shtse8/fireschema-runtime';
import type { FirestoreLike, DocumentReferenceLike, CollectionReferenceLike, CollectionSchema, FieldSchema } from '@shtse8/fireschema-runtime';

// Local Imports
import { ItemsData } from './items.types.js';
import { ItemsQueryBuilder } from './items.query.js';
import { ItemsUpdateBuilder } from './items.update.js';




import { TagsCollection } from './items/{itemsId}/tags.collection.js';



// Define types for data manipulation.
type ItemsAddData = {
  name: ItemsData['name'];
  value?: ItemsData['value'];
  createdAt?: ItemsData['createdAt'];
  tagsArray?: ItemsData['tagsArray'];
  address?: ItemsData['address'];
};

/**
 * Typed reference to the 'items' collection, extending BaseCollectionRef.
 */
export class ItemsCollection extends BaseCollectionRef<ItemsData, ItemsAddData> {

  /**
   * @param firestore The Firestore instance (client or admin).
   * @param parentRef Optional DocumentReference of the parent document (for subcollections).
   */
  // Use generic types from runtime for constructor parameters
  constructor(
    firestore: FirestoreLike,
    // collectionId is implicitly passed via super() call logic now
    // schema is processed internally before super()
    parentRef?: DocumentReferenceLike<DocumentDataLike> // Use generic type
  ) {
    // Process fields from the input schema to create a valid CollectionSchema for the runtime
    const processedFields: Record<string, FieldSchema> = {};
    
      processedFields['name'] = {
        
      };
    
      processedFields['value'] = {
        
      };
    
      processedFields['createdAt'] = {
        
        defaultValue: "serverTimestamp",
        
      };
    
      processedFields['tagsArray'] = {
        
      };
    
      processedFields['address'] = {
        
      };
    
    const schemaForRuntime: CollectionSchema = { fields: processedFields };

    // Call the base class constructor with correct arguments
    super(firestore, 'items', schemaForRuntime, parentRef);
  }

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   * @param id The ID of the document to update.
   * @returns A new ItemsUpdateBuilder instance.
   */
  update(id: string): ItemsUpdateBuilder {
    // Pass the generic DocumentReferenceLike from this.doc(id)
    return new ItemsUpdateBuilder(this.doc(id));
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   * @returns A new ItemsQueryBuilder instance.
   */
  query(): ItemsQueryBuilder {
    // Pass the generic FirestoreLike and CollectionReferenceLike
    return new ItemsQueryBuilder(this.firestore, this.ref);
  }

  // --- Subcollection Accessors ---




  /**
   * Access the 'tags' subcollection for a specific document.
   * @param documentId The ID of the parent 'items' document.
   * @returns A typed reference to the 'tags' subcollection.
   */
  tags(documentId: string): TagsCollection {
    // Process subcollection fields similarly to the main constructor
    const processedSubFields: Record<string, FieldSchema> = {};
    
      processedSubFields['label'] = {
        
      };
    
    const subSchema: CollectionSchema = { fields: processedSubFields };
    // Use the subCollection helper from BaseCollectionRef
    return this.subCollection(documentId, 'tags', TagsCollection, subSchema);
  }



  // --- Custom Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items.query.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as AdminFirestore, CollectionReference as AdminCollectionReference, DocumentSnapshot as AdminDocumentSnapshot, Timestamp as AdminTimestamp, DocumentReference as AdminDocumentReference, WhereFilterOp as AdminWhereFilterOp, OrderByDirection as AdminOrderByDirection } from 'firebase-admin/firestore';

// Runtime Imports - Base class and generic types
import { BaseQueryBuilder } from '@shtse8/fireschema-runtime'; // Use correct package name
import type { FirestoreLike, CollectionReferenceLike, DocumentSnapshotLike, TimestampLike, DocumentReferenceLike, WhereFilterOpLike, OrderByDirectionLike } from '@shtse8/fireschema-runtime';

// Local Imports
import { ItemsData } from './items.types.js';















/**
 * A typed query builder for the 'items' collection, extending BaseQueryBuilder.
 */
export class ItemsQueryBuilder extends BaseQueryBuilder<ItemsData> {

  // Constructor inherited from BaseQueryBuilder, accepts FirestoreLike and CollectionReferenceLike

  // --- Field-specific Where Methods ---
  // Overloads for 'name' field type safety based on operator
   
  whereName(op: '==', value: string): this;
   
  whereName(op: '!=', value: string): this;
   
  whereName(op: '<', value: string): this;
   
  whereName(op: '<=', value: string): this;
   
  whereName(op: '>', value: string): this;
   
  whereName(op: '>=', value: string): this;
   
  whereName(op: 'in', value: string[]): this;
   
  whereName(op: 'not-in', value: string[]): this;
  // Implementation signature for 'name'
  whereName(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('name', op, value);
  }
  // Overloads for 'value' field type safety based on operator
   
  whereValue(op: '==', value: number): this;
   
  whereValue(op: '!=', value: number): this;
   
  whereValue(op: '<', value: number): this;
   
  whereValue(op: '<=', value: number): this;
   
  whereValue(op: '>', value: number): this;
   
  whereValue(op: '>=', value: number): this;
   
  whereValue(op: 'in', value: number[]): this;
   
  whereValue(op: 'not-in', value: number[]): this;
  // Implementation signature for 'value'
  whereValue(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('value', op, value);
  }
  // Overloads for 'createdAt' field type safety based on operator
   
  whereCreatedAt(op: '==', value: TimestampLike): this;
   
  whereCreatedAt(op: '!=', value: TimestampLike): this;
   
  whereCreatedAt(op: '<', value: TimestampLike): this;
   
  whereCreatedAt(op: '<=', value: TimestampLike): this;
   
  whereCreatedAt(op: '>', value: TimestampLike): this;
   
  whereCreatedAt(op: '>=', value: TimestampLike): this;
   
  whereCreatedAt(op: 'in', value: TimestampLike[]): this;
   
  whereCreatedAt(op: 'not-in', value: TimestampLike[]): this;
  // Implementation signature for 'createdAt'
  whereCreatedAt(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('createdAt', op, value);
  }
  // Overloads for 'tagsArray' field type safety based on operator
   
  whereTagsArray(op: 'array-contains', value: string): this;
   
  whereTagsArray(op: 'array-contains-any', value: string[]): this;
   
  whereTagsArray(op: 'in', value: string[][]): this;
   
  whereTagsArray(op: 'not-in', value: string[][]): this;
  // Implementation signature for 'tagsArray'
  whereTagsArray(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('tagsArray', op, value);
  }
  // Overloads for 'address' field type safety based on operator
   
  whereAddress(op: '==', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }): this;
   
  whereAddress(op: '!=', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }): this;
   
  whereAddress(op: 'in', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }[]): this;
   
  whereAddress(op: 'not-in', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }[]): this;
  // Implementation signature for 'address'
  whereAddress(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('address', op, value);
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getSnapshot() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items.types.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { TimestampLike, GeoPointLike, DocumentReferenceLike, DocumentDataLike } from '@shtse8/fireschema-runtime';















/**
 * Represents the structure of a 'Items' document using generic types.
 * Description: A collection of test items.
 */
export interface ItemsData {
  /**
   * name (string, required)

   */
   
  name: string;
  /**
   * value (number)

   */
   
  value?: number;
  /**
   * createdAt (timestamp, required)

   */
   
  createdAt: TimestampLike;
  /**
   * tagsArray (array)

   */
   
  tagsArray?: string[];
  /**
   * address (map)

   */
   
  address?: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } };
}

// Potential future additions:
// - A class wrapper for data with helper methods?
// - Separate types for creation vs reading?"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items.update.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */

// Runtime Imports - Base class and generic types
import { BaseUpdateBuilder } from '@shtse8/fireschema-runtime'; // Correct package name
import type { DocumentReferenceLike, FieldValueLike, TimestampLike, GeoPointLike } from '@shtse8/fireschema-runtime'; // Import generic types

// Local Imports
import { ItemsData } from './items.types.js';















/**
 * A typed builder for creating update operations for 'items' documents, extending BaseUpdateBuilder.
 */
export class ItemsUpdateBuilder extends BaseUpdateBuilder<ItemsData> {

  // Constructor inherited from BaseUpdateBuilder (accepts DocumentReferenceLike)

  // --- Field Setters ---






  /** Sets the value for the 'name' field. */
  setName(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('name', value);
  }











  /** Sets the value for the 'value' field. */
  setValue(value: number | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('value', value);
  }



  /** Atomically increments the 'value' field. */
  incrementValue(value: number): this {
    return this._increment('value', value);
  }




  /** Deletes the 'value' field. */
  deleteValue(): this {
    return this._deleteField('value');
  }






  /** Sets the value for the 'createdAt' field. */
  setCreatedAt(value: TimestampLike | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('createdAt', value);
  }





  /** Sets the 'createdAt' field to the server timestamp. */
  setCreatedAtToServerTimestamp(): this {
    return this._serverTimestamp('createdAt');
  }







  /** Sets the value for the 'tagsArray' field. */
  setTagsArray(value: string[] | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('tagsArray', value);
  }





  /** Atomically adds elements to the 'tagsArray' array field. */
  arrayUnionTagsArray(values: string[] | string): this {
    return this._arrayUnion('tagsArray', Array.isArray(values) ? values : [values]);
  }

  /** Atomically removes elements from the 'tagsArray' array field. */
  arrayRemoveTagsArray(values: string[] | string): this {
    return this._arrayRemove('tagsArray', Array.isArray(values) ? values : [values]);
  }



  /** Deletes the 'tagsArray' field. */
  deleteTagsArray(): this {
    return this._deleteField('tagsArray');
  }






  /** Sets the value for the 'address' field. */
  setAddress(value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } } | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address', value);
  }






  /** Deletes the 'address' field. */
  deleteAddress(): this {
    return this._deleteField('address');
  }






  /** Sets the value for the 'address.street' field. */
  setAddressStreet(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.street', value);
  }











  /** Sets the value for the 'address.city' field. */
  setAddressCity(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.city', value);
  }











  /** Sets the value for the 'address.zip' field. */
  setAddressZip(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.zip', value);
  }






  /** Deletes the 'address.zip' field. */
  deleteAddressZip(): this {
    return this._deleteField('address.zip');
  }






  /** Sets the value for the 'address.coords' field. */
  setAddressCoords(value: { lat: number; lon: number } | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.coords', value);
  }






  /** Deletes the 'address.coords' field. */
  deleteAddressCoords(): this {
    return this._deleteField('address.coords');
  }






  /** Sets the value for the 'address.coords.lat' field. */
  setAddressCoordsLat(value: number | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.coords.lat', value);
  }



  /** Atomically increments the 'address.coords.lat' field. */
  incrementAddressCoordsLat(value: number): this {
    return this._increment('address.coords.lat', value);
  }









  /** Sets the value for the 'address.coords.lon' field. */
  setAddressCoordsLon(value: number | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.coords.lon', value);
  }



  /** Atomically increments the 'address.coords.lon' field. */
  incrementAddressCoordsLon(value: number): this {
    return this._increment('address.coords.lon', value);
  }






  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items/_itemsId_/tags.collection.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as AdminFirestore, DocumentReference as AdminDocumentReference, DocumentData as AdminDocumentData } from 'firebase-admin/firestore';

// Runtime Imports - Base class and generic types
import { BaseCollectionRef } from '@shtse8/fireschema-runtime';
import type { FirestoreLike, DocumentReferenceLike, CollectionReferenceLike, CollectionSchema, FieldSchema } from '@shtse8/fireschema-runtime';

// Local Imports
import { TagsData } from './tags.types.js';
import { TagsQueryBuilder } from './tags.query.js';
import { TagsUpdateBuilder } from './tags.update.js';



// Define types for data manipulation.
type TagsAddData = {
  label: TagsData['label'];
};

/**
 * Typed reference to the 'tags' collection, extending BaseCollectionRef.
 */
export class TagsCollection extends BaseCollectionRef<TagsData, TagsAddData> {

  /**
   * @param firestore The Firestore instance (client or admin).
   * @param parentRef Optional DocumentReference of the parent document (for subcollections).
   */
  // Use generic types from runtime for constructor parameters
  constructor(
    firestore: FirestoreLike,
    // collectionId is implicitly passed via super() call logic now
    // schema is processed internally before super()
    parentRef?: DocumentReferenceLike<DocumentDataLike> // Use generic type
  ) {
    // Process fields from the input schema to create a valid CollectionSchema for the runtime
    const processedFields: Record<string, FieldSchema> = {};
    
      processedFields['label'] = {
        
      };
    
    const schemaForRuntime: CollectionSchema = { fields: processedFields };

    // Call the base class constructor with correct arguments
    super(firestore, 'tags', schemaForRuntime, parentRef);
  }

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   * @param id The ID of the document to update.
   * @returns A new TagsUpdateBuilder instance.
   */
  update(id: string): TagsUpdateBuilder {
    // Pass the generic DocumentReferenceLike from this.doc(id)
    return new TagsUpdateBuilder(this.doc(id));
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   * @returns A new TagsQueryBuilder instance.
   */
  query(): TagsQueryBuilder {
    // Pass the generic FirestoreLike and CollectionReferenceLike
    return new TagsQueryBuilder(this.firestore, this.ref);
  }

  // --- Subcollection Accessors ---


  // --- Custom Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items/_itemsId_/tags.query.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as AdminFirestore, CollectionReference as AdminCollectionReference, DocumentSnapshot as AdminDocumentSnapshot, Timestamp as AdminTimestamp, DocumentReference as AdminDocumentReference, WhereFilterOp as AdminWhereFilterOp, OrderByDirection as AdminOrderByDirection } from 'firebase-admin/firestore';

// Runtime Imports - Base class and generic types
import { BaseQueryBuilder } from '@shtse8/fireschema-runtime'; // Use correct package name
import type { FirestoreLike, CollectionReferenceLike, DocumentSnapshotLike, TimestampLike, DocumentReferenceLike, WhereFilterOpLike, OrderByDirectionLike } from '@shtse8/fireschema-runtime';

// Local Imports
import { TagsData } from './tags.types.js';







/**
 * A typed query builder for the 'tags' collection, extending BaseQueryBuilder.
 */
export class TagsQueryBuilder extends BaseQueryBuilder<TagsData> {

  // Constructor inherited from BaseQueryBuilder, accepts FirestoreLike and CollectionReferenceLike

  // --- Field-specific Where Methods ---
  // Overloads for 'label' field type safety based on operator
   
  whereLabel(op: '==', value: string): this;
   
  whereLabel(op: '!=', value: string): this;
   
  whereLabel(op: '<', value: string): this;
   
  whereLabel(op: '<=', value: string): this;
   
  whereLabel(op: '>', value: string): this;
   
  whereLabel(op: '>=', value: string): this;
   
  whereLabel(op: 'in', value: string[]): this;
   
  whereLabel(op: 'not-in', value: string[]): this;
  // Implementation signature for 'label'
  whereLabel(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('label', op, value);
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getSnapshot() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items/_itemsId_/tags.types.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { TimestampLike, GeoPointLike, DocumentReferenceLike, DocumentDataLike } from '@shtse8/fireschema-runtime';







/**
 * Represents the structure of a 'Tags' document using generic types.
 * Description: Tags for an item.
 */
export interface TagsData {
  /**
   * label (string, required)

   */
   
  label: string;
}

// Potential future additions:
// - A class wrapper for data with helper methods?
// - Separate types for creation vs reading?"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: items/_itemsId_/tags.update.ts-admin 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */

// Runtime Imports - Base class and generic types
import { BaseUpdateBuilder } from '@shtse8/fireschema-runtime'; // Correct package name
import type { DocumentReferenceLike, FieldValueLike, TimestampLike, GeoPointLike } from '@shtse8/fireschema-runtime'; // Import generic types

// Local Imports
import { TagsData } from './tags.types.js';







/**
 * A typed builder for creating update operations for 'tags' documents, extending BaseUpdateBuilder.
 */
export class TagsUpdateBuilder extends BaseUpdateBuilder<TagsData> {

  // Constructor inherited from BaseUpdateBuilder (accepts DocumentReferenceLike)

  // --- Field Setters ---






  /** Sets the value for the 'label' field. */
  setLabel(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('label', value);
  }








  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript admin files matching snapshots: package.json-admin 1`] = `
"{
  "name": "@test/generated-ts-admin",
  "version": "1.0.0",
  "description": "Generated Firestore ODM for @test/generated-ts-admin",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "clean": "npx rimraf dist",
    "build": "bun run clean && tsc -b",
    "test": "jest"
  },
  "peerDependencies": {
    "@shtse8/fireschema-runtime": "^0.1.0",
    "firebase": "^9.0.0 || ^10.0.0 || ^11.0.0",
    "firebase-admin": "^11.0.0 || ^12.0.0"
  },
  "peerDependenciesMeta": {
    "firebase": {
      "optional": true
    },
    "firebase-admin": {
      "optional": true
    }
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "firebase": "^10.12.4",
    "firebase-admin": "^12.0.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.0.0"
  }
}"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items.collection.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as ClientFirestore, DocumentReference as ClientDocumentReference, DocumentData as ClientDocumentData } from 'firebase/firestore';

// Runtime Imports - Base class and generic types
import { BaseCollectionRef } from '@shtse8/fireschema-runtime';
import type { FirestoreLike, DocumentReferenceLike, CollectionReferenceLike, CollectionSchema, FieldSchema } from '@shtse8/fireschema-runtime';

// Local Imports
import { ItemsData } from './items.types.js';
import { ItemsQueryBuilder } from './items.query.js';
import { ItemsUpdateBuilder } from './items.update.js';




import { TagsCollection } from './items/{itemsId}/tags.collection.js';



// Define types for data manipulation.
type ItemsAddData = {
  name: ItemsData['name'];
  value?: ItemsData['value'];
  createdAt?: ItemsData['createdAt'];
  tagsArray?: ItemsData['tagsArray'];
  address?: ItemsData['address'];
};

/**
 * Typed reference to the 'items' collection, extending BaseCollectionRef.
 */
export class ItemsCollection extends BaseCollectionRef<ItemsData, ItemsAddData> {

  /**
   * @param firestore The Firestore instance (client or admin).
   * @param parentRef Optional DocumentReference of the parent document (for subcollections).
   */
  // Use generic types from runtime for constructor parameters
  constructor(
    firestore: FirestoreLike,
    // collectionId is implicitly passed via super() call logic now
    // schema is processed internally before super()
    parentRef?: DocumentReferenceLike<DocumentDataLike> // Use generic type
  ) {
    // Process fields from the input schema to create a valid CollectionSchema for the runtime
    const processedFields: Record<string, FieldSchema> = {};
    
      processedFields['name'] = {
        
      };
    
      processedFields['value'] = {
        
      };
    
      processedFields['createdAt'] = {
        
        defaultValue: "serverTimestamp",
        
      };
    
      processedFields['tagsArray'] = {
        
      };
    
      processedFields['address'] = {
        
      };
    
    const schemaForRuntime: CollectionSchema = { fields: processedFields };

    // Call the base class constructor with correct arguments
    super(firestore, 'items', schemaForRuntime, parentRef);
  }

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   * @param id The ID of the document to update.
   * @returns A new ItemsUpdateBuilder instance.
   */
  update(id: string): ItemsUpdateBuilder {
    // Pass the generic DocumentReferenceLike from this.doc(id)
    return new ItemsUpdateBuilder(this.doc(id));
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   * @returns A new ItemsQueryBuilder instance.
   */
  query(): ItemsQueryBuilder {
    // Pass the generic FirestoreLike and CollectionReferenceLike
    return new ItemsQueryBuilder(this.firestore, this.ref);
  }

  // --- Subcollection Accessors ---




  /**
   * Access the 'tags' subcollection for a specific document.
   * @param documentId The ID of the parent 'items' document.
   * @returns A typed reference to the 'tags' subcollection.
   */
  tags(documentId: string): TagsCollection {
    // Process subcollection fields similarly to the main constructor
    const processedSubFields: Record<string, FieldSchema> = {};
    
      processedSubFields['label'] = {
        
      };
    
    const subSchema: CollectionSchema = { fields: processedSubFields };
    // Use the subCollection helper from BaseCollectionRef
    return this.subCollection(documentId, 'tags', TagsCollection, subSchema);
  }



  // --- Custom Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items.query.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as ClientFirestore, CollectionReference as ClientCollectionReference, DocumentSnapshot as ClientDocumentSnapshot, Timestamp as ClientTimestamp, DocumentReference as ClientDocumentReference, WhereFilterOp as ClientWhereFilterOp, OrderByDirection as ClientOrderByDirection } from 'firebase/firestore';

// Runtime Imports - Base class and generic types
import { BaseQueryBuilder } from '@shtse8/fireschema-runtime'; // Use correct package name
import type { FirestoreLike, CollectionReferenceLike, DocumentSnapshotLike, TimestampLike, DocumentReferenceLike, WhereFilterOpLike, OrderByDirectionLike } from '@shtse8/fireschema-runtime';

// Local Imports
import { ItemsData } from './items.types.js';















/**
 * A typed query builder for the 'items' collection, extending BaseQueryBuilder.
 */
export class ItemsQueryBuilder extends BaseQueryBuilder<ItemsData> {

  // Constructor inherited from BaseQueryBuilder, accepts FirestoreLike and CollectionReferenceLike

  // --- Field-specific Where Methods ---
  // Overloads for 'name' field type safety based on operator
   
  whereName(op: '==', value: string): this;
   
  whereName(op: '!=', value: string): this;
   
  whereName(op: '<', value: string): this;
   
  whereName(op: '<=', value: string): this;
   
  whereName(op: '>', value: string): this;
   
  whereName(op: '>=', value: string): this;
   
  whereName(op: 'in', value: string[]): this;
   
  whereName(op: 'not-in', value: string[]): this;
  // Implementation signature for 'name'
  whereName(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('name', op, value);
  }
  // Overloads for 'value' field type safety based on operator
   
  whereValue(op: '==', value: number): this;
   
  whereValue(op: '!=', value: number): this;
   
  whereValue(op: '<', value: number): this;
   
  whereValue(op: '<=', value: number): this;
   
  whereValue(op: '>', value: number): this;
   
  whereValue(op: '>=', value: number): this;
   
  whereValue(op: 'in', value: number[]): this;
   
  whereValue(op: 'not-in', value: number[]): this;
  // Implementation signature for 'value'
  whereValue(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('value', op, value);
  }
  // Overloads for 'createdAt' field type safety based on operator
   
  whereCreatedAt(op: '==', value: TimestampLike): this;
   
  whereCreatedAt(op: '!=', value: TimestampLike): this;
   
  whereCreatedAt(op: '<', value: TimestampLike): this;
   
  whereCreatedAt(op: '<=', value: TimestampLike): this;
   
  whereCreatedAt(op: '>', value: TimestampLike): this;
   
  whereCreatedAt(op: '>=', value: TimestampLike): this;
   
  whereCreatedAt(op: 'in', value: TimestampLike[]): this;
   
  whereCreatedAt(op: 'not-in', value: TimestampLike[]): this;
  // Implementation signature for 'createdAt'
  whereCreatedAt(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('createdAt', op, value);
  }
  // Overloads for 'tagsArray' field type safety based on operator
   
  whereTagsArray(op: 'array-contains', value: string): this;
   
  whereTagsArray(op: 'array-contains-any', value: string[]): this;
   
  whereTagsArray(op: 'in', value: string[][]): this;
   
  whereTagsArray(op: 'not-in', value: string[][]): this;
  // Implementation signature for 'tagsArray'
  whereTagsArray(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('tagsArray', op, value);
  }
  // Overloads for 'address' field type safety based on operator
   
  whereAddress(op: '==', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }): this;
   
  whereAddress(op: '!=', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }): this;
   
  whereAddress(op: 'in', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }[]): this;
   
  whereAddress(op: 'not-in', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }[]): this;
  // Implementation signature for 'address'
  whereAddress(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('address', op, value);
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getSnapshot() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items.types.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { TimestampLike, GeoPointLike, DocumentReferenceLike, DocumentDataLike } from '@shtse8/fireschema-runtime';















/**
 * Represents the structure of a 'Items' document using generic types.
 * Description: A collection of test items.
 */
export interface ItemsData {
  /**
   * name (string, required)

   */
   
  name: string;
  /**
   * value (number)

   */
   
  value?: number;
  /**
   * createdAt (timestamp, required)

   */
   
  createdAt: TimestampLike;
  /**
   * tagsArray (array)

   */
   
  tagsArray?: string[];
  /**
   * address (map)

   */
   
  address?: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } };
}

// Potential future additions:
// - A class wrapper for data with helper methods?
// - Separate types for creation vs reading?"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items.update.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */

// Runtime Imports - Base class and generic types
import { BaseUpdateBuilder } from '@shtse8/fireschema-runtime'; // Correct package name
import type { DocumentReferenceLike, FieldValueLike, TimestampLike, GeoPointLike } from '@shtse8/fireschema-runtime'; // Import generic types

// Local Imports
import { ItemsData } from './items.types.js';















/**
 * A typed builder for creating update operations for 'items' documents, extending BaseUpdateBuilder.
 */
export class ItemsUpdateBuilder extends BaseUpdateBuilder<ItemsData> {

  // Constructor inherited from BaseUpdateBuilder (accepts DocumentReferenceLike)

  // --- Field Setters ---






  /** Sets the value for the 'name' field. */
  setName(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('name', value);
  }











  /** Sets the value for the 'value' field. */
  setValue(value: number | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('value', value);
  }



  /** Atomically increments the 'value' field. */
  incrementValue(value: number): this {
    return this._increment('value', value);
  }




  /** Deletes the 'value' field. */
  deleteValue(): this {
    return this._deleteField('value');
  }






  /** Sets the value for the 'createdAt' field. */
  setCreatedAt(value: TimestampLike | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('createdAt', value);
  }





  /** Sets the 'createdAt' field to the server timestamp. */
  setCreatedAtToServerTimestamp(): this {
    return this._serverTimestamp('createdAt');
  }







  /** Sets the value for the 'tagsArray' field. */
  setTagsArray(value: string[] | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('tagsArray', value);
  }





  /** Atomically adds elements to the 'tagsArray' array field. */
  arrayUnionTagsArray(values: string[] | string): this {
    return this._arrayUnion('tagsArray', Array.isArray(values) ? values : [values]);
  }

  /** Atomically removes elements from the 'tagsArray' array field. */
  arrayRemoveTagsArray(values: string[] | string): this {
    return this._arrayRemove('tagsArray', Array.isArray(values) ? values : [values]);
  }



  /** Deletes the 'tagsArray' field. */
  deleteTagsArray(): this {
    return this._deleteField('tagsArray');
  }






  /** Sets the value for the 'address' field. */
  setAddress(value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } } | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address', value);
  }






  /** Deletes the 'address' field. */
  deleteAddress(): this {
    return this._deleteField('address');
  }






  /** Sets the value for the 'address.street' field. */
  setAddressStreet(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.street', value);
  }











  /** Sets the value for the 'address.city' field. */
  setAddressCity(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.city', value);
  }











  /** Sets the value for the 'address.zip' field. */
  setAddressZip(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.zip', value);
  }






  /** Deletes the 'address.zip' field. */
  deleteAddressZip(): this {
    return this._deleteField('address.zip');
  }






  /** Sets the value for the 'address.coords' field. */
  setAddressCoords(value: { lat: number; lon: number } | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.coords', value);
  }






  /** Deletes the 'address.coords' field. */
  deleteAddressCoords(): this {
    return this._deleteField('address.coords');
  }






  /** Sets the value for the 'address.coords.lat' field. */
  setAddressCoordsLat(value: number | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.coords.lat', value);
  }



  /** Atomically increments the 'address.coords.lat' field. */
  incrementAddressCoordsLat(value: number): this {
    return this._increment('address.coords.lat', value);
  }









  /** Sets the value for the 'address.coords.lon' field. */
  setAddressCoordsLon(value: number | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('address.coords.lon', value);
  }



  /** Atomically increments the 'address.coords.lon' field. */
  incrementAddressCoordsLon(value: number): this {
    return this._increment('address.coords.lon', value);
  }






  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items/_itemsId_/tags.collection.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as ClientFirestore, DocumentReference as ClientDocumentReference, DocumentData as ClientDocumentData } from 'firebase/firestore';

// Runtime Imports - Base class and generic types
import { BaseCollectionRef } from '@shtse8/fireschema-runtime';
import type { FirestoreLike, DocumentReferenceLike, CollectionReferenceLike, CollectionSchema, FieldSchema } from '@shtse8/fireschema-runtime';

// Local Imports
import { TagsData } from './tags.types.js';
import { TagsQueryBuilder } from './tags.query.js';
import { TagsUpdateBuilder } from './tags.update.js';



// Define types for data manipulation.
type TagsAddData = {
  label: TagsData['label'];
};

/**
 * Typed reference to the 'tags' collection, extending BaseCollectionRef.
 */
export class TagsCollection extends BaseCollectionRef<TagsData, TagsAddData> {

  /**
   * @param firestore The Firestore instance (client or admin).
   * @param parentRef Optional DocumentReference of the parent document (for subcollections).
   */
  // Use generic types from runtime for constructor parameters
  constructor(
    firestore: FirestoreLike,
    // collectionId is implicitly passed via super() call logic now
    // schema is processed internally before super()
    parentRef?: DocumentReferenceLike<DocumentDataLike> // Use generic type
  ) {
    // Process fields from the input schema to create a valid CollectionSchema for the runtime
    const processedFields: Record<string, FieldSchema> = {};
    
      processedFields['label'] = {
        
      };
    
    const schemaForRuntime: CollectionSchema = { fields: processedFields };

    // Call the base class constructor with correct arguments
    super(firestore, 'tags', schemaForRuntime, parentRef);
  }

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   * @param id The ID of the document to update.
   * @returns A new TagsUpdateBuilder instance.
   */
  update(id: string): TagsUpdateBuilder {
    // Pass the generic DocumentReferenceLike from this.doc(id)
    return new TagsUpdateBuilder(this.doc(id));
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   * @returns A new TagsQueryBuilder instance.
   */
  query(): TagsQueryBuilder {
    // Pass the generic FirestoreLike and CollectionReferenceLike
    return new TagsQueryBuilder(this.firestore, this.ref);
  }

  // --- Subcollection Accessors ---


  // --- Custom Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items/_itemsId_/tags.query.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { Firestore as ClientFirestore, CollectionReference as ClientCollectionReference, DocumentSnapshot as ClientDocumentSnapshot, Timestamp as ClientTimestamp, DocumentReference as ClientDocumentReference, WhereFilterOp as ClientWhereFilterOp, OrderByDirection as ClientOrderByDirection } from 'firebase/firestore';

// Runtime Imports - Base class and generic types
import { BaseQueryBuilder } from '@shtse8/fireschema-runtime'; // Use correct package name
import type { FirestoreLike, CollectionReferenceLike, DocumentSnapshotLike, TimestampLike, DocumentReferenceLike, WhereFilterOpLike, OrderByDirectionLike } from '@shtse8/fireschema-runtime';

// Local Imports
import { TagsData } from './tags.types.js';







/**
 * A typed query builder for the 'tags' collection, extending BaseQueryBuilder.
 */
export class TagsQueryBuilder extends BaseQueryBuilder<TagsData> {

  // Constructor inherited from BaseQueryBuilder, accepts FirestoreLike and CollectionReferenceLike

  // --- Field-specific Where Methods ---
  // Overloads for 'label' field type safety based on operator
   
  whereLabel(op: '==', value: string): this;
   
  whereLabel(op: '!=', value: string): this;
   
  whereLabel(op: '<', value: string): this;
   
  whereLabel(op: '<=', value: string): this;
   
  whereLabel(op: '>', value: string): this;
   
  whereLabel(op: '>=', value: string): this;
   
  whereLabel(op: 'in', value: string[]): this;
   
  whereLabel(op: 'not-in', value: string[]): this;
  // Implementation signature for 'label'
  whereLabel(
    op: WhereFilterOpLike, // Use generic WhereFilterOpLike
    value: any
  ): this {
    // Call the protected _where method from the base class
    return this._where('label', op, value);
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getSnapshot() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items/_itemsId_/tags.types.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import type { TimestampLike, GeoPointLike, DocumentReferenceLike, DocumentDataLike } from '@shtse8/fireschema-runtime';







/**
 * Represents the structure of a 'Tags' document using generic types.
 * Description: Tags for an item.
 */
export interface TagsData {
  /**
   * label (string, required)

   */
   
  label: string;
}

// Potential future additions:
// - A class wrapper for data with helper methods?
// - Separate types for creation vs reading?"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: items/_itemsId_/tags.update.ts-client 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */

// Runtime Imports - Base class and generic types
import { BaseUpdateBuilder } from '@shtse8/fireschema-runtime'; // Correct package name
import type { DocumentReferenceLike, FieldValueLike, TimestampLike, GeoPointLike } from '@shtse8/fireschema-runtime'; // Import generic types

// Local Imports
import { TagsData } from './tags.types.js';







/**
 * A typed builder for creating update operations for 'tags' documents, extending BaseUpdateBuilder.
 */
export class TagsUpdateBuilder extends BaseUpdateBuilder<TagsData> {

  // Constructor inherited from BaseUpdateBuilder (accepts DocumentReferenceLike)

  // --- Field Setters ---






  /** Sets the value for the 'label' field. */
  setLabel(value: string | FieldValueLike): this { // method.fieldType includes FieldValueLike
    return this._set('label', value);
  }








  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
}"
`;

exports[`FireSchema Generator should generate TypeScript client files matching snapshots: package.json-client 1`] = `
"{
  "name": "@test/generated-ts-client",
  "version": "1.0.0",
  "description": "Generated Firestore ODM for @test/generated-ts-client",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "clean": "npx rimraf dist",
    "build": "bun run clean && tsc -b",
    "test": "jest"
  },
  "peerDependencies": {
    "@shtse8/fireschema-runtime": "^0.1.0",
    "firebase": "^9.0.0 || ^10.0.0 || ^11.0.0",
    "firebase-admin": "^11.0.0 || ^12.0.0"
  },
  "peerDependenciesMeta": {
    "firebase": {
      "optional": true
    },
    "firebase-admin": {
      "optional": true
    }
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "firebase": "^10.12.4",
    "firebase-admin": "^12.0.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.0.0"
  }
}"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items.collection.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  Firestore,
  CollectionReference, // Keep for type annotation if needed, but base handles creation
  DocumentReference,
  DocumentData, // Needed for parentRef typing and subCollection helper
  // serverTimestamp, // Handled by base class applyDefaults
  // increment, // Not used directly here
  // arrayUnion, // Not used directly here
  // arrayRemove, // Not used directly here
  // deleteField, // Not used directly here
  // Basic CRUD functions (collection, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc) are handled by base
} from 'firebase/firestore';
// Runtime Imports
import { BaseCollectionRef, CollectionSchema, FieldSchema } from '@fireschema/ts-runtime'; // Removed FirestoreFunctions import

// Local Imports
import { ItemsData } from './items.types.js';
import { ItemsQueryBuilder } from './items.query.js';
import { ItemsUpdateBuilder } from './items.update.js';




import { TagsCollection } from './items/{itemsId}/tags.collection.js';



// Define types for data manipulation.
// AddData: Makes fields optional if they have a default value or are not required.
// NOTE: This might need refinement if base class handles defaults differently.
type ItemsAddData = {
  name: ItemsData['name'];
  value?: ItemsData['value'];
  createdAt?: ItemsData['createdAt'];
  address?: ItemsData['address'];
};
// UpdateData: Type used by UpdateBuilder, defined there or implicitly via Firestore types.

/**
 * Typed reference to the 'items' collection, extending BaseCollectionRef.
 */
export class ItemsCollection extends BaseCollectionRef<ItemsData, ItemsAddData> {

  /**
   * @param firestore The Firestore instance.
   * @param parentRef Optional DocumentReference of the parent document (for subcollections).
   */
  // Constructor needs to accept all potential args for both root and subcollection instantiation
  constructor(
    firestore: Firestore,
    collectionId: string,
    // firestoreFunctions removed
    schema?: CollectionSchema,
    parentRef?: DocumentReference<DocumentData>
  ) {
    // Process fields from the input schema to create a valid CollectionSchema for the runtime
    const processedFields: Record<string, FieldSchema> = {};
    
      processedFields['name'] = {
        
        // Add other allowed FieldSchema properties here if needed
      };
    
      processedFields['value'] = {
        
        // Add other allowed FieldSchema properties here if needed
      };
    
      processedFields['createdAt'] = {
        
        defaultValue: "serverTimestamp",
        
        // Add other allowed FieldSchema properties here if needed
      };
    
      processedFields['address'] = {
        
        // Add other allowed FieldSchema properties here if needed
      };
    
    const schemaForRuntime: CollectionSchema = { fields: processedFields };

    // Call the base class constructor, passing the resolved collectionId and schema
    // Pass firestoreFunctions to the base class constructor
    // Removed firestoreFunctions from super() call
    super(firestore, collectionId, schema ?? schemaForRuntime, parentRef);
  }

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   * @param id The ID of the document to update.
   * @returns A new ItemsUpdateBuilder instance.
   */
  update(id: string): ItemsUpdateBuilder {
    // Returns the specific generated UpdateBuilder
    return new ItemsUpdateBuilder(this.doc(id));
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   * @returns A new ItemsQueryBuilder instance.
   */
  query(): ItemsQueryBuilder {
    // Returns the specific generated QueryBuilder
    return new ItemsQueryBuilder(this.firestore, this.ref); // Pass firestore and ref
  }

  // --- Subcollection Accessors ---




  /**
   * Access the 'tags' subcollection for a specific document.
   * @param documentId The ID of the parent 'items' document.
   * @returns A typed reference to the 'tags' subcollection.
   */
  tags(documentId: string): TagsCollection {
    // Use the helper method from BaseCollectionRef
    // Process subcollection fields similarly to the main constructor
    const processedSubFields: Record<string, FieldSchema> = {};
    
      processedSubFields['label'] = {
        
      };
    
    const subSchema: CollectionSchema = { fields: processedSubFields };
    // Pass the instance's firestoreFunctions down to the subcollection helper
    // Pass only the required arguments to the subCollection helper
    // Removed firestoreFunctions from subCollection call
    return this.subCollection(documentId, 'tags', TagsCollection, subSchema);
  }



  // --- Custom Methods Placeholder ---
  // Example: findByEmail(email: string) { ... } - Add custom query methods here if needed
}"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items.query.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  Firestore,
  CollectionReference,
  // Query, // Handled by base class
  // QueryConstraint, // Handled by base class
  // query, // Handled by base class
  // where as firestoreWhere, // Handled by base class _where
  // orderBy, // Handled by base class
  // limit, // Handled by base class
  // getDocs, // Handled by base class get() / getSnapshot()
  // limitToLast, // Handled by base class
  // startAt, // Handled by base class
  // startAfter, // Handled by base class
  // endAt, // Handled by base class
  // endBefore, // Handled by base class
  DocumentSnapshot, // Needed for cursor method signatures in base class
  WhereFilterOp, // Needed for where method signatures
  OrderByDirection, // Needed for orderBy signature in base class
  Timestamp,        // Needed for timestamp field queries
  DocumentReference // Needed for reference field queries
} from 'firebase/firestore';
// Runtime Imports
import { BaseQueryBuilder } from '@fireschema/ts-runtime'; // Adjust path/package name as needed

// Local Imports
import { ItemsData } from './items.types.js';













/**
 * A typed query builder for the 'items' collection, extending BaseQueryBuilder.
 */
export class ItemsQueryBuilder extends BaseQueryBuilder<ItemsData> {

  // Constructor is inherited from BaseQueryBuilder

  // --- Field-specific Where Methods ---
  // Overloads for 'name' field type safety based on operator
  whereName(op: '==', value: string): this;
  whereName(op: '!=', value: string): this;
  whereName(op: '<', value: string): this;
  whereName(op: '<=', value: string): this;
  whereName(op: '>', value: string): this;
  whereName(op: '>=', value: string): this;
  whereName(op: 'in', value: string[]): this;
  whereName(op: 'not-in', value: string[]): this;
  // Implementation signature for 'name'
  whereName(
    op: WhereFilterOp, // Use WhereFilterOp for implementation signature
    value: any   // Use any for implementation signature
  ): this {
    // Call the protected _where method from the base class
    return this._where('name', op, value);
  }
  // Overloads for 'value' field type safety based on operator
  whereValue(op: '==', value: number): this;
  whereValue(op: '!=', value: number): this;
  whereValue(op: '<', value: number): this;
  whereValue(op: '<=', value: number): this;
  whereValue(op: '>', value: number): this;
  whereValue(op: '>=', value: number): this;
  whereValue(op: 'in', value: number[]): this;
  whereValue(op: 'not-in', value: number[]): this;
  // Implementation signature for 'value'
  whereValue(
    op: WhereFilterOp, // Use WhereFilterOp for implementation signature
    value: any   // Use any for implementation signature
  ): this {
    // Call the protected _where method from the base class
    return this._where('value', op, value);
  }
  // Overloads for 'createdAt' field type safety based on operator
  whereCreatedAt(op: '==', value: Timestamp): this;
  whereCreatedAt(op: '!=', value: Timestamp): this;
  whereCreatedAt(op: '<', value: Timestamp): this;
  whereCreatedAt(op: '<=', value: Timestamp): this;
  whereCreatedAt(op: '>', value: Timestamp): this;
  whereCreatedAt(op: '>=', value: Timestamp): this;
  whereCreatedAt(op: 'in', value: Timestamp[]): this;
  whereCreatedAt(op: 'not-in', value: Timestamp[]): this;
  // Implementation signature for 'createdAt'
  whereCreatedAt(
    op: WhereFilterOp, // Use WhereFilterOp for implementation signature
    value: any   // Use any for implementation signature
  ): this {
    // Call the protected _where method from the base class
    return this._where('createdAt', op, value);
  }
  // Overloads for 'address' field type safety based on operator
  whereAddress(op: '==', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }): this;
  whereAddress(op: '!=', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }): this;
  whereAddress(op: 'in', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }[]): this;
  whereAddress(op: 'not-in', value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } }[]): this;
  // Implementation signature for 'address'
  whereAddress(
    op: WhereFilterOp, // Use WhereFilterOp for implementation signature
    value: any   // Use any for implementation signature
  ): this {
    // Call the protected _where method from the base class
    return this._where('address', op, value);
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getSnapshot() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
  // Example: findByStatus(status: string) { return this._where('status', '==', status); }
}"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items.types.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import { Timestamp, GeoPoint, DocumentReference, DocumentData } from 'firebase/firestore';













/**
 * Represents the structure of a 'Items' document.
 * Description: A collection of test items.
 */
export interface ItemsData {
  /** name (string, required) */
  name: string;
  /** value (number) */
  value?: number;
  /** createdAt (timestamp, required) */
  createdAt: Timestamp;
  /** address (map) */
  address?: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } };
}

// Potential future additions:
// - A class wrapper for data with helper methods?
// - Separate types for creation vs reading?"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items.update.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  DocumentReference,
  // updateDoc, // Handled by base class commit()
  FieldValue, // Keep for potential direct use if needed, though base provides helpers
  Timestamp,  // Needed for timestamp field setters
  // DocumentReference, // Needed for reference field setters (Already imported above)
  // serverTimestamp, // Handled by base class helper _serverTimestamp()
  // increment, // Handled by base class helper _increment()
  // arrayUnion, // Handled by base class helper _arrayUnion()
  // arrayRemove, // Handled by base class helper _arrayRemove()
  // deleteField, // Handled by base class helper _deleteField()
} from 'firebase/firestore';
// Runtime Imports
import { BaseUpdateBuilder } from '@fireschema/ts-runtime'; // Adjust path/package name as needed

// Local Imports
import { ItemsData } from './items.types.js';













/**
 * A typed builder for creating update operations for 'items' documents, extending BaseUpdateBuilder.
 */
export class ItemsUpdateBuilder extends BaseUpdateBuilder<ItemsData> {

  // Constructor is inherited from BaseUpdateBuilder
  // _docRef and _updateData are managed by the base class

  // --- Field Setters ---






  /** Sets the value for the 'name' field. */
  setName(value: string | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('name', value);
  }











  /** Sets the value for the 'value' field. */
  setValue(value: number | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('value', value);
  }



  /** Atomically increments the 'value' field. */
  incrementValue(value: number): this { // Remove 'set' prefix for atomic ops
    return this._increment('value', value);
  }




  /** Deletes the 'value' field. */
  deleteValue(): this { // Remove 'set' prefix
    return this._deleteField('value');
  }






  /** Sets the value for the 'createdAt' field. */
  setCreatedAt(value: Timestamp | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('createdAt', value);
  }





  /** Sets the 'createdAt' field to the server timestamp. */
  setCreatedAtToServerTimestamp(): this { // Keep 'set' prefix for this specific operation
    return this._serverTimestamp('createdAt');
  }







  /** Sets the value for the 'address' field. */
  setAddress(value: { street: string; city: string; zip?: string; coords?: { lat: number; lon: number } } | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('address', value);
  }






  /** Deletes the 'address' field. */
  deleteAddress(): this { // Remove 'set' prefix
    return this._deleteField('address');
  }






  /** Sets the value for the 'address.street' field. */
  setAddressStreet(value: string | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('address.street', value);
  }











  /** Sets the value for the 'address.city' field. */
  setAddressCity(value: string | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('address.city', value);
  }











  /** Sets the value for the 'address.zip' field. */
  setAddressZip(value: string | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('address.zip', value);
  }






  /** Deletes the 'address.zip' field. */
  deleteAddressZip(): this { // Remove 'set' prefix
    return this._deleteField('address.zip');
  }






  /** Sets the value for the 'address.coords' field. */
  setAddressCoords(value: { lat: number; lon: number } | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('address.coords', value);
  }






  /** Deletes the 'address.coords' field. */
  deleteAddressCoords(): this { // Remove 'set' prefix
    return this._deleteField('address.coords');
  }






  /** Sets the value for the 'address.coords.lat' field. */
  setAddressCoordsLat(value: number | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('address.coords.lat', value);
  }



  /** Atomically increments the 'address.coords.lat' field. */
  incrementAddressCoordsLat(value: number): this { // Remove 'set' prefix for atomic ops
    return this._increment('address.coords.lat', value);
  }









  /** Sets the value for the 'address.coords.lon' field. */
  setAddressCoordsLon(value: number | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('address.coords.lon', value);
  }



  /** Atomically increments the 'address.coords.lon' field. */
  incrementAddressCoordsLon(value: number): this { // Remove 'set' prefix for atomic ops
    return this._increment('address.coords.lon', value);
  }






  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
  // Example: markAsRead() { return this._set('read', true); }
}"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items/_itemsId_/tags.collection.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  Firestore,
  CollectionReference, // Keep for type annotation if needed, but base handles creation
  DocumentReference,
  DocumentData, // Needed for parentRef typing and subCollection helper
  // serverTimestamp, // Handled by base class applyDefaults
  // increment, // Not used directly here
  // arrayUnion, // Not used directly here
  // arrayRemove, // Not used directly here
  // deleteField, // Not used directly here
  // Basic CRUD functions (collection, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc) are handled by base
} from 'firebase/firestore';
// Runtime Imports
import { BaseCollectionRef, CollectionSchema, FieldSchema } from '@fireschema/ts-runtime'; // Removed FirestoreFunctions import

// Local Imports
import { TagsData } from './tags.types.js';
import { TagsQueryBuilder } from './tags.query.js';
import { TagsUpdateBuilder } from './tags.update.js';



// Define types for data manipulation.
// AddData: Makes fields optional if they have a default value or are not required.
// NOTE: This might need refinement if base class handles defaults differently.
type TagsAddData = {
  label: TagsData['label'];
};
// UpdateData: Type used by UpdateBuilder, defined there or implicitly via Firestore types.

/**
 * Typed reference to the 'tags' collection, extending BaseCollectionRef.
 */
export class TagsCollection extends BaseCollectionRef<TagsData, TagsAddData> {

  /**
   * @param firestore The Firestore instance.
   * @param parentRef Optional DocumentReference of the parent document (for subcollections).
   */
  // Constructor needs to accept all potential args for both root and subcollection instantiation
  constructor(
    firestore: Firestore,
    collectionId: string,
    // firestoreFunctions removed
    schema?: CollectionSchema,
    parentRef?: DocumentReference<DocumentData>
  ) {
    // Process fields from the input schema to create a valid CollectionSchema for the runtime
    const processedFields: Record<string, FieldSchema> = {};
    
      processedFields['label'] = {
        
        // Add other allowed FieldSchema properties here if needed
      };
    
    const schemaForRuntime: CollectionSchema = { fields: processedFields };

    // Call the base class constructor, passing the resolved collectionId and schema
    // Pass firestoreFunctions to the base class constructor
    // Removed firestoreFunctions from super() call
    super(firestore, collectionId, schema ?? schemaForRuntime, parentRef);
  }

  // Methods like doc(), add(), set(), get(), delete() are inherited from BaseCollectionRef

  /**
   * Creates a new UpdateBuilder instance for the document with the given ID.
   * @param id The ID of the document to update.
   * @returns A new TagsUpdateBuilder instance.
   */
  update(id: string): TagsUpdateBuilder {
    // Returns the specific generated UpdateBuilder
    return new TagsUpdateBuilder(this.doc(id));
  }

  /**
   * Creates a new QueryBuilder instance for this collection.
   * @returns A new TagsQueryBuilder instance.
   */
  query(): TagsQueryBuilder {
    // Returns the specific generated QueryBuilder
    return new TagsQueryBuilder(this.firestore, this.ref); // Pass firestore and ref
  }

  // --- Subcollection Accessors ---


  // --- Custom Methods Placeholder ---
  // Example: findByEmail(email: string) { ... } - Add custom query methods here if needed
}"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items/_itemsId_/tags.query.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  Firestore,
  CollectionReference,
  // Query, // Handled by base class
  // QueryConstraint, // Handled by base class
  // query, // Handled by base class
  // where as firestoreWhere, // Handled by base class _where
  // orderBy, // Handled by base class
  // limit, // Handled by base class
  // getDocs, // Handled by base class get() / getSnapshot()
  // limitToLast, // Handled by base class
  // startAt, // Handled by base class
  // startAfter, // Handled by base class
  // endAt, // Handled by base class
  // endBefore, // Handled by base class
  DocumentSnapshot, // Needed for cursor method signatures in base class
  WhereFilterOp, // Needed for where method signatures
  OrderByDirection, // Needed for orderBy signature in base class
  Timestamp,        // Needed for timestamp field queries
  DocumentReference // Needed for reference field queries
} from 'firebase/firestore';
// Runtime Imports
import { BaseQueryBuilder } from '@fireschema/ts-runtime'; // Adjust path/package name as needed

// Local Imports
import { TagsData } from './tags.types.js';







/**
 * A typed query builder for the 'tags' collection, extending BaseQueryBuilder.
 */
export class TagsQueryBuilder extends BaseQueryBuilder<TagsData> {

  // Constructor is inherited from BaseQueryBuilder

  // --- Field-specific Where Methods ---
  // Overloads for 'label' field type safety based on operator
  whereLabel(op: '==', value: string): this;
  whereLabel(op: '!=', value: string): this;
  whereLabel(op: '<', value: string): this;
  whereLabel(op: '<=', value: string): this;
  whereLabel(op: '>', value: string): this;
  whereLabel(op: '>=', value: string): this;
  whereLabel(op: 'in', value: string[]): this;
  whereLabel(op: 'not-in', value: string[]): this;
  // Implementation signature for 'label'
  whereLabel(
    op: WhereFilterOp, // Use WhereFilterOp for implementation signature
    value: any   // Use any for implementation signature
  ): this {
    // Call the protected _where method from the base class
    return this._where('label', op, value);
  }
  // --- End Field-specific Where Methods ---

  // Methods like orderBy(), limit(), limitToLast(), startAt(), startAfter(),
  // endBefore(), endAt(), get(), getSnapshot() are inherited from BaseQueryBuilder.

  // --- Custom Query Methods Placeholder ---
  // Example: findByStatus(status: string) { return this._where('status', '==', status); }
}"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items/_itemsId_/tags.types.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import { Timestamp, GeoPoint, DocumentReference, DocumentData } from 'firebase/firestore';







/**
 * Represents the structure of a 'Tags' document.
 * Description: Tags for an item.
 */
export interface TagsData {
  /** label (string, required) */
  label: string;
}

// Potential future additions:
// - A class wrapper for data with helper methods?
// - Separate types for creation vs reading?"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: items/_itemsId_/tags.update.ts 1`] = `
"/**
 * Generated by firestore-odm
 * Do not edit manually.
 */
import {
  DocumentReference,
  // updateDoc, // Handled by base class commit()
  FieldValue, // Keep for potential direct use if needed, though base provides helpers
  Timestamp,  // Needed for timestamp field setters
  // DocumentReference, // Needed for reference field setters (Already imported above)
  // serverTimestamp, // Handled by base class helper _serverTimestamp()
  // increment, // Handled by base class helper _increment()
  // arrayUnion, // Handled by base class helper _arrayUnion()
  // arrayRemove, // Handled by base class helper _arrayRemove()
  // deleteField, // Handled by base class helper _deleteField()
} from 'firebase/firestore';
// Runtime Imports
import { BaseUpdateBuilder } from '@fireschema/ts-runtime'; // Adjust path/package name as needed

// Local Imports
import { TagsData } from './tags.types.js';







/**
 * A typed builder for creating update operations for 'tags' documents, extending BaseUpdateBuilder.
 */
export class TagsUpdateBuilder extends BaseUpdateBuilder<TagsData> {

  // Constructor is inherited from BaseUpdateBuilder
  // _docRef and _updateData are managed by the base class

  // --- Field Setters ---






  /** Sets the value for the 'label' field. */
  setLabel(value: string | FieldValue): this {
    // Use the pre-calculated field path and method name
    return this._set('label', value);
  }








  // --- End Field Setters ---

  // commit() method is inherited from BaseUpdateBuilder

  // --- Custom Update Methods Placeholder ---
  // Example: markAsRead() { return this._set('read', true); }
}"
`;

exports[`FireSchema Generator should generate TypeScript files matching snapshots: package.json 1`] = `
"{
  "name": "@test/generated-ts",
  "version": "1.0.0",
  "description": "Generated Firestore ODM for @test/generated-ts",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "clean": "npx rimraf dist",
    "build": "bun run clean && tsc -b",
    "test": "jest"
  },
  "peerDependencies": {
    "firebase": "^9.0.0 || ^10.0.0 || ^11.0.0",
    "@fireschema/ts-runtime": "^0.1.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "firebase": "^10.12.4",
    "jest": "^29.7.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.0.0"
  }
}"
`;

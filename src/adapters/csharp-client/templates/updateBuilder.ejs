<%%# src/adapters/csharp-client/templates/updateBuilder.ejs -%>
<%%
// Helper to generate PascalCase names
const toPascalCase = (str) => {
    if (!str) return '';
    return str.replace(/[-_](\w)/g, (_, c) => c.toUpperCase())
              .replace(/^./, (c) => c.toUpperCase());
};

// Helper to generate singular PascalCase names (basic)
const singularizePascal = (name) => {
    const singular = name.endsWith('ies') ? name.substring(0, name.length - 3) + 'y' :
                     (name.endsWith('s') && !name.endsWith('ss')) ? name.substring(0, name.length - 1) : name;
    return toPascalCase(singular);
};

// Helper function to convert JSON Schema types to C# types (similar to model.ejs)
const toCSharpType = (property) => {
  switch (property.type) {
    case 'string':
      if (property.format === 'date-time') return 'Timestamp?';
      return 'string';
    case 'number':
    case 'integer':
      return 'double?';
    case 'boolean':
      return 'bool?';
    case 'array':
      const itemType = property.items && property.items.type ? toCSharpType(property.items) : 'object';
      const finalItemType = itemType.endsWith('?') ? itemType.slice(0, -1) : itemType;
      return `List<${finalItemType}>`;
    case 'object':
       if (property.$ref) return 'DocumentReference';
       if (property.properties && property.properties._seconds && property.properties._nanoseconds) return 'Timestamp?';
       return 'Dictionary<string, object>'; // Or specific type if map properties are defined
    case 'timestamp': return 'Timestamp?'; // Explicitly handle timestamp type
    case 'geopoint': return 'GeoPoint?'; // Explicitly handle geopoint type
    case 'reference': return 'DocumentReference'; // Explicitly handle reference type
    case 'null': return 'object';
    default: return 'object';
  }
};


const collectionPascalName = toPascalCase(collectionName); // e.g., Users
const modelName = `${singularizePascal(collectionName)}Data`; // e.g., UserData
const updateBuilderName = `${collectionPascalName}UpdateBuilder`; // e.g., UsersUpdateBuilder
-%>
using Google.Cloud.Firestore;
using FireSchema.CS.Runtime.Core; // Import runtime core
using System; // For Func, Expression if used later
using System.Collections.Generic; // For List, Dictionary

namespace <%%= namespace %>
{
    /// <summary>
    /// Typed update builder for documents in the '<%%= collectionName %>' collection.
    /// Provides methods for specifying field updates.
    /// Generated by FireSchema.
    /// </summary>
    public class <%%= updateBuilderName %> : BaseUpdateBuilder<<%%= modelName %>>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="<%%= updateBuilderName %>"/> class.
        /// </summary>
        /// <param name="docRef">The DocumentReference to update.</param>
        public <%%= updateBuilderName %>(DocumentReference docRef) : base(docRef)
        {
        }

        // --- Strongly-typed Set methods for each field ---

<%% Object.entries(properties).forEach(([propName, propSchema]) => {
       const pascalName = toPascalCase(propName);
       const csharpType = toCSharpType(propSchema);
       // Use the non-nullable version for the method parameter type if the C# type is nullable
       const paramType = csharpType.endsWith('?') ? csharpType.slice(0, -1) : csharpType;
-%>
        /// <summary>
        /// Sets the value for the '<%%= propName %>' field.
        /// </summary>
        /// <param name="value">The new value for <%%= pascalName %>.</param>
        /// <returns>The current update builder instance.</returns>
        public <%%= updateBuilderName %> Set<%%= pascalName %>(<%%= csharpType %> value) // Keep C# type nullable if applicable
        {
            // Use the original Firestore field name
            base.Set("<%%= propName %>", value);
            return this;
        }

<%%   // Add methods for specific atomic operations if applicable
       if (propSchema.type === 'number' || propSchema.type === 'integer') { -%>
        /// <summary>
        /// Atomically increments the '<%%= propName %>' field by the specified value.
        /// </summary>
        /// <param name="value">The value to increment by.</param>
        /// <returns>The current update builder instance.</returns>
        public <%%= updateBuilderName %> Increment<%%= pascalName %>(double value)
        {
            base.Set("<%%= propName %>", FieldValue.Increment(value));
            return this;
        }

<%%   } else if (propSchema.type === 'array') {
           const itemType = propSchema.items && propSchema.items.type ? toCSharpType(propSchema.items) : 'object';
           const finalItemType = itemType.endsWith('?') ? itemType.slice(0, -1) : itemType;
-%>
        /// <summary>
        /// Atomically adds the specified elements to the '<%%= propName %>' array field,
        /// ensuring uniqueness.
        /// </summary>
        /// <param name="values">The elements to add.</param>
        /// <returns>The current update builder instance.</returns>
        public <%%= updateBuilderName %> Union<%%= pascalName %>(params <%%= finalItemType %>[] values)
        {
             // Need to cast object[] for FieldValue.ArrayUnion
            base.Set("<%%= propName %>", FieldValue.ArrayUnion(values.Cast<object>().ToArray()));
            return this;
        }

        /// <summary>
        /// Atomically removes all instances of the specified elements from the '<%%= propName %>' array field.
        /// </summary>
        /// <param name="values">The elements to remove.</param>
        /// <returns>The current update builder instance.</returns>
        public <%%= updateBuilderName %> Remove<%%= pascalName %>(params <%%= finalItemType %>[] values)
        {
             // Need to cast object[] for FieldValue.ArrayRemove
            base.Set("<%%= propName %>", FieldValue.ArrayRemove(values.Cast<object>().ToArray()));
            return this;
        }

<%%   } else if (propSchema.serverTimestamp === true) { // Check for serverTimestamp flag
-%>
       /// <summary>
       /// Sets the '<%%= propName %>' field to the server timestamp.
       /// </summary>
       /// <returns>The current update builder instance.</returns>
        public <%%= updateBuilderName %> Set<%%= pascalName %>ToServerTimestamp()
        {
            base.SetServerTimestamp("<%%= propName %>");
            return this;
        }
<%%   }
   }); // End forEach property
-%>

        /// <summary>
        /// Adds an operation to delete the specified field.
        /// </summary>
        /// <param name="fieldPath">The path to the field to delete.</param>
        /// <returns>The current update builder instance.</returns>
        public new <%%= updateBuilderName %> Delete(FieldPath fieldPath)
        {
            base.Delete(fieldPath);
            return this;
        }

        /// <summary>
        /// Adds an operation to delete the specified field using a string path.
        /// </summary>
        /// <param name="fieldPath">The dot-separated path to the field to delete.</param>
        /// <returns>The current update builder instance.</returns>
        public new <%%= updateBuilderName %> Delete(string fieldPath)
        {
            base.Delete(fieldPath);
            return this;
        }

        /// <summary>
        /// Adds an operation to set the specified field to the server timestamp.
        /// </summary>
        /// <param name="fieldPath">The path to the field to update.</param>
        /// <returns>The current update builder instance.</returns>
        public new <%%= updateBuilderName %> SetServerTimestamp(FieldPath fieldPath)
        {
             base.SetServerTimestamp(fieldPath);
             return this;
        }

        /// <summary>
        /// Adds an operation to set the specified field to the server timestamp using a string path.
        /// </summary>
        /// <param name="fieldPath">The dot-separated path to the field to update.</param>
        /// <returns>The current update builder instance.</returns>
        public new <%%= updateBuilderName %> SetServerTimestamp(string fieldPath)
        {
             base.SetServerTimestamp(fieldPath);
             return this;
        }
    }
}
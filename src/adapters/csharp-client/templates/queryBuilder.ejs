<%%# src/adapters/csharp-client/templates/queryBuilder.ejs -%>
<%%
// Helper to generate PascalCase names
const toPascalCase = (str) => {
    if (!str) return '';
    return str.replace(/[-_](\w)/g, (_, c) => c.toUpperCase())
              .replace(/^./, (c) => c.toUpperCase());
};

// Helper to generate singular PascalCase names (basic)
const singularizePascal = (name) => {
    const singular = name.endsWith('ies') ? name.substring(0, name.length - 3) + 'y' :
                     (name.endsWith('s') && !name.endsWith('ss')) ? name.substring(0, name.length - 1) : name;
    return toPascalCase(singular);
};

const collectionPascalName = toPascalCase(collectionName); // e.g., Users
const modelName = `${singularizePascal(collectionName)}Data`; // e.g., UserData
const queryBuilderName = `${collectionPascalName}QueryBuilder`; // e.g., UsersQueryBuilder
-%>
using Google.Cloud.Firestore;
using FireSchema.CS.Runtime.Core; // Import runtime core
using System; // For Func, Expression if used later
using System.Linq.Expressions; // For strongly-typed Where clauses

namespace <%%= namespace %>
{
    /// <summary>
    /// Typed query builder for the '<%%= collectionName %>' collection.
    /// Provides methods for filtering and ordering documents.
    /// Generated by FireSchema.
    /// </summary>
    public class <%%= queryBuilderName %> : BaseQueryBuilder<<%%= modelName %>>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="<%%= queryBuilderName %>"/> class.
        /// </summary>
        /// <param name="query">The underlying Firestore query.</param>
        public <%%= queryBuilderName %>(Query query) : base(query)
        {
        }

        // --- Strongly-typed Where methods ---

<%% Object.entries(properties).forEach(([propName, propSchema]) => {
       const pascalName = toPascalCase(propName);
       // Determine the C# type again (could be refactored into a shared helper)
       let csharpType = 'object'; // Default fallback
       switch (propSchema.type) {
           case 'string': csharpType = 'string'; break;
           case 'number': case 'integer': csharpType = 'double?'; break; // Assuming nullable double
           case 'boolean': csharpType = 'bool?'; break;
           case 'timestamp': csharpType = 'Timestamp?'; break; // Google.Cloud.Firestore.Timestamp
           case 'geopoint': csharpType = 'GeoPoint?'; break; // Google.Cloud.Firestore.GeoPoint
           case 'reference': csharpType = 'DocumentReference'; break; // Google.Cloud.Firestore.DocumentReference
           // Array and Map might need special handling or generic Where methods
           // For now, let's generate for basic types
       }
       // Only generate specific Where methods for easily comparable types
       if (['string', 'double?', 'bool?', 'Timestamp?', 'DocumentReference'].includes(csharpType)) {
-%>
        /// <summary>
        /// Creates a new query that filters documents where the '<%%= propName %>' field
        /// matches the specified condition.
        /// </summary>
        /// <param name="op">The comparison operator.</param>
        /// <param name="value">The value to compare against.</param>
        /// <returns>A new query builder instance with the filter applied.</returns>
        public <%%= queryBuilderName %> Where<%%= pascalName %>(QueryOperator op, <%%= csharpType %> value)
        {
            // Return new instance for immutability
            return new <%%= queryBuilderName %>(FirestoreQuery.Where("<%%= propName %>", op, value));
        }

<%%   } // End if basic type
   }); // End forEach property
-%>

        // --- Override OrderBy for type safety (optional but good practice) ---

<%% Object.entries(properties).forEach(([propName, propSchema]) => {
       const pascalName = toPascalCase(propName);
       // Only generate OrderBy for types that are typically orderable
       if (['string', 'number', 'integer', 'timestamp', 'boolean'].includes(propSchema.type)) {
-%>
        /// <summary>
        /// Creates a new query that orders documents by the '<%%= propName %>' field.
        /// </summary>
        /// <param name="direction">The direction to order by.</param>
        /// <returns>A new query builder instance with the ordering applied.</returns>
        public <%%= queryBuilderName %> OrderBy<%%= pascalName %>(QueryDirection direction)
        {
            return new <%%= queryBuilderName %>(FirestoreQuery.OrderBy("<%%= propName %>", direction));
        }

<%%   } // End if orderable type
   }); // End forEach property
-%>

        // --- Override Limit methods to return the specific builder type ---

        /// <summary>
        /// Creates a new query that limits the number of documents returned.
        /// </summary>
        /// <param name="limit">The maximum number of documents to return.</param>
        /// <returns>A new query builder instance with the limit applied.</returns>
        public new <%%= queryBuilderName %> Limit(int limit)
        {
             return new <%%= queryBuilderName %>(FirestoreQuery.Limit(limit));
        }

        /// <summary>
        /// Creates a new query that limits the number of documents returned from the end of the ordered results.
        /// </summary>
        /// <param name="limit">The maximum number of documents to return.</param>
        /// <returns>A new query builder instance with the limit applied.</returns>
        public new <%%= queryBuilderName %> LimitToLast(int limit)
        {
             return new <%%= queryBuilderName %>(FirestoreQuery.LimitToLast(limit));
        }

        // --- TODO: Add strongly-typed pagination methods ---
        // public UsersQueryBuilder StartAt(UserData documentSnapshot) => ...
    }
}
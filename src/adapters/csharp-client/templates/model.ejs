<%%# src/adapters/csharp-client/templates/model.ejs -%>
<%%
// Helper function to convert JSON Schema types to C# types
const toCSharpType = (property) => {
  // Basic type mapping (can be expanded)
  switch (property.type) {
    case 'string':
      // Check for common formats
      if (property.format === 'date-time') return 'Timestamp?'; // Google.Cloud.Firestore.Timestamp
      if (property.format === 'uri') return 'string';
      return 'string';
    case 'number':
    case 'integer':
      // Consider format for float/double/decimal if needed
      return 'double?'; // Use nullable double for flexibility
    case 'boolean':
      return 'bool?';
    case 'array':
      // Determine item type recursively or assume basic types for now
      const itemType = property.items && property.items.type ? toCSharpType(property.items) : 'object';
      // Handle potential nested nullables if itemType itself is nullable
      const finalItemType = itemType.endsWith('?') ? itemType.slice(0, -1) : itemType;
      return `List<${finalItemType}>`; // System.Collections.Generic.List
    case 'object':
       // Check if it's a DocumentReference based on a custom property or pattern
       if (property.$ref) {
           // Assuming $ref format like '#/definitions/CollectionName' -> generate 'DocumentReference'
           // Or potentially a specific type if we generate nested classes/structs later
           return 'DocumentReference'; // Google.Cloud.Firestore.DocumentReference
       }
       // Check for Timestamp pattern
       if (property.properties && property.properties._seconds && property.properties._nanoseconds) {
           return 'Timestamp?';
       }
       // TODO: Handle nested objects - generate separate classes/structs?
       return 'Dictionary<string, object>'; // Default for generic objects
    case 'null':
        return 'object'; // Or handle based on context if combined with other types
    default:
      return 'object'; // Default fallback
  }
};

// Helper to generate C# property attributes
const getPropertyAttributes = (propName, schemaProperty) => {
    let attributes = `[FirestoreProperty(\"${propName}\")]`;
    // Add other attributes as needed, e.g., for server timestamps
    if (schemaProperty.serverTimestamp === true) { // Assuming a custom 'serverTimestamp' flag in schema
        attributes += '\\n        [ServerTimestamp]';
    }
    return attributes;
};

// Helper to generate C# property definition
const generateProperty = (propName, schemaProperty) => {
    const csharpType = toCSharpType(schemaProperty);
    const attributes = getPropertyAttributes(propName, schemaProperty);
    // Use PascalCase for C# property names
    const pascalName = propName.charAt(0).toUpperCase() + propName.slice(1);
    return `
        ${attributes}
        public ${csharpType} ${pascalName} { get; set; }
`;
};
-%>
using Google.Cloud.Firestore;
using System.Collections.Generic; // For List and Dictionary

namespace <%%= namespace %> // Assuming namespace is passed in data
{
    /// <summary>
    /// Represents a document in the '<%%= collectionName %>' collection.
    /// Generated by FireSchema.
    /// </summary>
    [FirestoreData]
    public class <%%= modelName %> // Assuming modelName is passed (e.g., UserData)
    {
        /// <summary>
        /// The document ID. This is not stored in Firestore but used locally.
        /// </summary>
        [FirestoreDocumentId]
        public string Id { get; set; }

<%% Object.entries(properties).forEach(([propName, propSchema]) => { -%>
        /// <summary>
        /// Maps to the '<%%= propName %>' field in Firestore.
        /// Type: <%%= propSchema.type %><% if (propSchema.description) { %> | Description: <%%= propSchema.description %><% } %>
        /// </summary>
<%%= generateProperty(propName, propSchema) %>
<%% }); -%>

        // TODO: Add constructor(s) if needed?
        // TODO: Add methods like ToDictionary() if not handled by FirestoreData?
    }
}
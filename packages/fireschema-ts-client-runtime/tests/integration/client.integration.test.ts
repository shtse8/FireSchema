import { initializeApp, deleteApp, FirebaseApp } from 'firebase/app';
import { getFirestore, connectFirestoreEmulator, terminate, Firestore, doc, getDoc, deleteDoc, collection, getDocs, query, writeBatch, serverTimestamp, Timestamp, DocumentReference, DocumentData, FieldValue } from 'firebase/firestore'; // Added DocumentData, FieldValue
import { ClientBaseCollectionRef, CollectionSchema } from '../../src/baseCollection'; // Import the runtime base class and schema type
import { ClientBaseQueryBuilder } from '../../src/baseQueryBuilder';   // Import Query Builder
import { ClientBaseUpdateBuilder } from '../../src/baseUpdateBuilder'; // Import Update Builder

// --- Test Setup ---
const FIREBASE_PROJECT_ID = 'fireschema-test-emulator';
const FIRESTORE_EMULATOR_HOST = '127.0.0.1';
const FIRESTORE_EMULATOR_PORT = 8080; // Default Firestore emulator port

let app: FirebaseApp;
let firestore: Firestore;

// Simple interface for test data
interface TestData {
  id?: string; // Optional because ID is assigned by Firestore or used for get/delete
  name: string;
  value: number;
  tags?: string[];
  lastUpdated?: Timestamp;
}

// Simple Add type (usually excludes generated fields like id)

// --- Subcollection Types ---
interface SubTestData {
  id?: string;
  description: string;
  count: number;
}
type SubTestAddData = Omit<SubTestData, 'id'>;

// Subcollection class
class TestSubCollection extends ClientBaseCollectionRef<SubTestData, SubTestAddData> {
  // Match the signature expected by the base subCollection method
  constructor(
    firestore: Firestore,
    collectionId: string, // Added collectionId
    schema?: CollectionSchema, // Added schema
    parentRef?: DocumentReference<DocumentData> // Use DocumentData for base compatibility
  ) {
    // Pass all arguments to super
    super(firestore, collectionId, schema, parentRef);
  }
  // Add specific query/update methods if needed
}

type TestAddData = Omit<TestData, 'id'>;

// A concrete class extending the base for testing
// In a real scenario, this would be generated by FireSchema
class TestCollection extends ClientBaseCollectionRef<TestData, TestAddData> {
  constructor(db: Firestore, schema?: CollectionSchema) {
    // No schema provided for this basic test
    super(db, 'test-items', schema);
  }

  // Method to create a query builder instance
  query(): ClientBaseQueryBuilder<TestData> {
    return new ClientBaseQueryBuilder<TestData>(this.firestore, this.ref);
  }

  // Method to create an update builder instance
  update(id: string): ClientBaseUpdateBuilder<TestData> {
    const docRef = this.doc(id); // Use base class doc() method
    return new ClientBaseUpdateBuilder<TestData>(docRef);
  }

  // Method to access the subcollection using the public base method
  subItems(parentId: string): TestSubCollection {
    // Define the schema for the subcollection if needed by the base method or constructor
    const subSchema = undefined; // Or provide actual schema if required
    // Use the now public subCollection method from the base class
    return this.subCollection(parentId, 'sub-items', TestSubCollection, subSchema);
  }
  // Add specific methods if needed, otherwise inherit base methods
}

let testCollection: TestCollection;

beforeAll(async () => {
  // Initialize Firebase App for testing
  app = initializeApp({ projectId: FIREBASE_PROJECT_ID });
  firestore = getFirestore(app);

  // Connect to Firestore Emulator
  connectFirestoreEmulator(firestore, FIRESTORE_EMULATOR_HOST, FIRESTORE_EMULATOR_PORT);

  // Instantiate our test collection class
  testCollection = new TestCollection(firestore);

  console.log(`Connected to Firestore emulator at ${FIRESTORE_EMULATOR_HOST}:${FIRESTORE_EMULATOR_PORT}. Clearing test collection...`);
  // Clear the test collection before all tests
  await clearTestCollection(); // Note: clearTestCollection needs to be defined before this line
  console.log('Test collection cleared.');

  // Clear the test collection before tests (optional, but good practice)
  // Note: A helper function to clear collection might be needed for robustness
  console.log(`Connected to Firestore emulator at ${FIRESTORE_EMULATOR_HOST}:${FIRESTORE_EMULATOR_PORT}`);
});

afterAll(async () => {
  // Terminate Firestore connection
  await terminate(firestore);
  // Delete Firebase App
  await deleteApp(app);
  console.log('Disconnected from Firestore emulator.');
});

// Clear collection before each test run for isolation
// Helper function to clear the collection
async function clearTestCollection() {
    // Check if testCollection is initialized before using its ref
    if (!testCollection || !testCollection.ref) return;
    const q = query(testCollection.ref); // Use the collection ref from the instance
    const snapshot = await getDocs(q);
    if (snapshot.empty) {
        return; // Nothing to clear
    }
    const batch = writeBatch(firestore);
    snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
    });
    await batch.commit();
}

// Clear collection before each test run for isolation
beforeEach(clearTestCollection);


// Removed duplicate beforeEach cleanup block

describe('Client Runtime Integration Tests', () => {

  it('should add a document and retrieve it', async () => {
    const dataToAdd: TestAddData = { name: 'Integration Test Item', value: 123 };
    let docRef;
    try {
      docRef = await testCollection.add(dataToAdd);
      expect(docRef).toBeDefined();
      expect(docRef.id).toBeTruthy();

      // Retrieve the document directly using the runtime's get method
      const retrievedData = await testCollection.get(docRef.id);

      expect(retrievedData).toBeDefined();
      // ID is not part of the data payload itself in Firestore
      expect(retrievedData).toEqual(expect.objectContaining(dataToAdd));

    } finally {
      // Cleanup: delete the added document
      if (docRef?.id) {
        await testCollection.delete(docRef.id);
      }
    }
  });

  it('should set a document with a specific ID and retrieve it', async () => {
    const docId = 'specific-test-id';
    const dataToSet: TestAddData = { name: 'Specific ID Item', value: 456 };
    try {
      // Use the set method from the base class
      await testCollection.set(docId, dataToSet);

      // Retrieve using the base class get method
      const retrievedData = await testCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData).toEqual(expect.objectContaining(dataToSet));

    } finally {
      // Cleanup
      await testCollection.delete(docId);
    }
  });

   it('should delete a document', async () => {
    const docId = 'to-be-deleted';
    const dataToSet: TestAddData = { name: 'Delete Me', value: 789 };
    try {
      await testCollection.set(docId, dataToSet);

      // Verify it exists first
      let retrievedData = await testCollection.get(docId);
      expect(retrievedData).toBeDefined();

      // Delete using the base class method
      await testCollection.delete(docId);

      // Verify it's gone
      retrievedData = await testCollection.get(docId);
      expect(retrievedData).toBeUndefined();

    } catch (error) {
        // Ensure cleanup happens even if assertions fail mid-test
        try { await testCollection.delete(docId); } catch (e) {}
        throw error; // Re-throw the original error
    }
  }); // End of 'delete a document' test

  // --- Query Tests --- // Moved here

  it('should query documents using where', async () => {
    const id1 = 'query-test-1';
    const id2 = 'query-test-2';
    const data1: TestAddData = { name: 'Query A', value: 100 };
    const data2: TestAddData = { name: 'Query B', value: 200 };
    const data3: TestAddData = { name: 'Query C', value: 100 }; // Same value as data1
    try {
      await testCollection.set(id1, data1);
      await testCollection.set(id2, data2);
      await testCollection.set('query-test-3', data3);

      const queryBuilder = testCollection.query();
      // Use public where method if available, otherwise cast for testing protected method
      const results = await (queryBuilder as any)._where('value', '==', 100).get();

      expect(results).toHaveLength(2);
      // Check if the results contain the expected names (order might vary)
      const names = results.map((r: TestData) => r.name); // Added type annotation
      expect(names).toContain('Query A');
      expect(names).toContain('Query C');
      expect(names).not.toContain('Query B');

    } finally {
      // Cleanup
      await clearTestCollection();
    }
  });

  it('should query documents using orderBy and limit', async () => {
    const dataSet = [
      { id: 'order-1', data: { name: 'Zebra', value: 1 } },
      { id: 'order-2', data: { name: 'Apple', value: 2 } },
      { id: 'order-3', data: { name: 'Mango', value: 3 } },
    ];
    try {
      // Add test data
      for (const item of dataSet) {
        await testCollection.set(item.id, item.data);
      }

      const queryBuilder = testCollection.query();
      const results = await queryBuilder.orderBy('name', 'asc').limit(2).get();

      expect(results).toHaveLength(2);
      expect(results[0].name).toBe('Apple');
      expect(results[1].name).toBe('Mango');

    } finally {
      // Cleanup
      await clearTestCollection();
    }
  });

  it('should query documents using "in" operator', async () => {
    const dataSet = [
      { id: 'in-1', data: { name: 'A', value: 1 } },
      { id: 'in-2', data: { name: 'B', value: 2 } },
      { id: 'in-3', data: { name: 'C', value: 3 } },
    ];
    try {
      for (const item of dataSet) {
        await testCollection.set(item.id, item.data);
      }

      const queryBuilder = testCollection.query();
      // Use protected _where for testing base class logic
      const results = await (queryBuilder as any)._where('name', 'in', ['A', 'C']).get();

      expect(results).toHaveLength(2);
      const names = results.map((r: TestData) => r.name);
      expect(names).toContain('A');
      expect(names).toContain('C');
      expect(names).not.toContain('B');

    } finally {
      await clearTestCollection();
    }
  });

  it('should query documents using multiple where clauses', async () => {
    const dataSet = [
      { id: 'multi-1', data: { name: 'X', value: 10, tags: ['a'] } },
      { id: 'multi-2', data: { name: 'Y', value: 20, tags: ['a', 'b'] } },
      { id: 'multi-3', data: { name: 'Z', value: 10, tags: ['b'] } },
    ];
    try {
      for (const item of dataSet) {
        await testCollection.set(item.id, item.data);
      }

      const queryBuilder = testCollection.query();
      const results = await (queryBuilder as any)
        ._where('value', '==', 10)
        ._where('tags', 'array-contains', 'a') // Firestore requires index for this
        .get();

      // Note: This specific query (equality on one field, array-contains on another)
      // might require a composite index in a real Firestore setup.
      // The test assumes the emulator handles it or the necessary index exists.
      expect(results).toHaveLength(1);
      expect(results[0].name).toBe('X');

    } finally {
      await clearTestCollection();
    }
  });

  it('should update nested fields using the update builder', async () => {
    const docId = 'update-nested-test';
    // Define a type with a nested object
    interface NestedTestData extends DocumentData {
      config?: {
        isEnabled?: boolean;
        level?: number | FieldValue; // Allow increment
      }
    }
    // Use 'any' for AddData for simplicity in this test
    class NestedTestCollection extends ClientBaseCollectionRef<NestedTestData, any> {
        constructor(db: Firestore) { super(db, 'nested-test'); }
        update(id: string): ClientBaseUpdateBuilder<NestedTestData> {
            return new ClientBaseUpdateBuilder<NestedTestData>(this.doc(id));
        }
    }
    const nestedCollection = new NestedTestCollection(firestore);
    const initialData = { config: { isEnabled: false, level: 1 } };

    try {
      await nestedCollection.set(docId, initialData);

      // Update nested fields
      await nestedCollection.update(docId)
        ._set('config.isEnabled', true) // Update boolean
        ._increment('config.level', 2)   // Increment nested number
        .commit();

      const retrievedData = await nestedCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData?.config?.isEnabled).toBe(true);
      expect(retrievedData?.config?.level).toBe(3); // 1 + 2

    } finally {
      // Cleanup
      await nestedCollection.delete(docId);
    }
  });

  it('should query documents using cursors (startAfter)', async () => {
    const dataSet = [
      { id: 'cursor-1', data: { name: 'One', value: 1 } },
      { id: 'cursor-2', data: { name: 'Two', value: 2 } },
      { id: 'cursor-3', data: { name: 'Three', value: 3 } },
    ];
    try {
      for (const item of dataSet) {
        await testCollection.set(item.id, item.data);
      }

      // Get the document snapshot for 'One' using the SDK's getDoc
      const docRefToStartAfter = testCollection.doc('cursor-1'); // Get the DocumentReference
      const startAfterDoc = await getDoc(docRefToStartAfter); // Fetch the snapshot
      expect(startAfterDoc).toBeDefined();

      const queryBuilder = testCollection.query();
      const results = await queryBuilder
        .orderBy('value', 'asc') // Cursors require orderBy
        .startAfter(startAfterDoc)
        .get();

      expect(results).toHaveLength(2);
      expect(results[0].name).toBe('Two');
      expect(results[1].name).toBe('Three');

    } finally {
      await clearTestCollection();
    }
  });

  // --- Update Tests --- // Moved here

  it('should update a document using the update builder', async () => {
    const docId = 'update-test-1';
    const initialData: TestAddData = { name: 'Initial Name', value: 50 };
    try {
      await testCollection.set(docId, initialData);

      const updateBuilder = testCollection.update(docId);
      // Use the now public methods (assuming previous change applied)
      await updateBuilder
        ._set('name', 'Updated Name' as any) // Direct set
        ._increment('value', 10)      // Increment
        ._arrayUnion('tags', ['new', 'updated']) // Array Union
        ._serverTimestamp('lastUpdated') // Server Timestamp
        .commit();

      const retrievedData = await testCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData?.name).toBe('Updated Name');
      expect(retrievedData?.value).toBe(60);
      expect(retrievedData?.tags).toEqual(['new', 'updated']);
      expect(retrievedData?.lastUpdated).toBeInstanceOf(Timestamp); // Check type

    } finally {
      // Cleanup
      await testCollection.delete(docId);
    }
  });

  it('should remove array elements and delete fields', async () => {
    const docId = 'update-test-2';
    const initialData: TestAddData = { name: 'Array Remove Test', value: 1, tags: ['a', 'b', 'c'] };
    try {
      await testCollection.set(docId, initialData);

      const updateBuilder = testCollection.update(docId);
      // Use the now public methods
      await updateBuilder
        ._arrayRemove('tags', ['b'] as any) // Array Remove
        ._deleteField('value')       // Delete Field
        .commit();

      const retrievedData = await testCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData?.name).toBe('Array Remove Test');
      expect(retrievedData?.tags).toEqual(['a', 'c']);
      expect(retrievedData?.value).toBeUndefined(); // Field should be deleted

    } finally {
      // Cleanup
       await testCollection.delete(docId); // Added cleanup
    }
  });

  // --- Default Value Test --- // Moved here

  it('should apply serverTimestamp default value from schema', async () => {
    const docId = 'default-value-test';
    const schemaWithDefault: CollectionSchema = {
      fields: {
        lastUpdated: { defaultValue: 'serverTimestamp' },
      },
    };
    // Instantiate a new collection reference WITH the schema
    const collectionWithSchema = new TestCollection(firestore, schemaWithDefault);
    const dataToAdd: TestAddData = { name: 'Default Timestamp', value: 1 }; // lastUpdated is omitted

    try {
      // Use set to test if ClientBaseCollectionRef applies defaults on set
      // (Requires ClientBaseCollectionRef.set to be updated similar to Admin)
      await collectionWithSchema.set(docId, dataToAdd);

      const retrievedData = await collectionWithSchema.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData?.name).toBe('Default Timestamp');
      expect(retrievedData?.value).toBe(1);
      // Check that the default value was applied
      expect(retrievedData?.lastUpdated).toBeInstanceOf(Timestamp);

    } finally {
      // Cleanup using the same collection reference
      await collectionWithSchema.delete(docId);
    }
  });

  // --- Subcollection Test --- // Moved here

  it('should add, get, and delete documents in a subcollection', async () => {
    const parentId = 'parent-doc-for-sub';
    const subDocId = 'sub-doc-1';
    const parentData: TestAddData = { name: 'Parent Doc', value: 1 };
    const subData: SubTestAddData = { description: 'Sub Item 1', count: 10 };

    try {
      // Create the parent document first
      await testCollection.set(parentId, parentData);

      // Get the subcollection reference
      const subCollection = testCollection.subItems(parentId); // Assumes subItems works
      expect(subCollection).toBeInstanceOf(TestSubCollection);
      expect(subCollection.ref.path).toBe(`${testCollection.ref.path}/${parentId}/sub-items`); // Verify path construction

      // Add a document to the subcollection
      const subDocRef = await subCollection.add(subData);
      expect(subDocRef).toBeDefined();
      const addedSubDocId = subDocRef.id;

      // Get the subcollection document using its ID
      let retrievedSubData = await subCollection.get(addedSubDocId);
      expect(retrievedSubData).toBeDefined();
      expect(retrievedSubData).toEqual(expect.objectContaining(subData));

      // Set a document with a specific ID in the subcollection
      await subCollection.set(subDocId, { description: 'Specific Sub Item', count: 20 });
      retrievedSubData = await subCollection.get(subDocId);
      expect(retrievedSubData?.description).toBe('Specific Sub Item');

      // Delete from subcollection
      await subCollection.delete(addedSubDocId);
      retrievedSubData = await subCollection.get(addedSubDocId);
      expect(retrievedSubData).toBeUndefined();

      await subCollection.delete(subDocId);
      retrievedSubData = await subCollection.get(subDocId);
      expect(retrievedSubData).toBeUndefined();

    } finally {
      // Cleanup: Delete parent doc (subcollection is deleted automatically)
      await testCollection.delete(parentId);
    }
  });

  // Add more tests for:
  // - Updates (requires BaseUpdateBuilder integration)
  // - Queries (requires BaseQueryBuilder integration)
  // - Subcollections (if applicable)
  // - Default values (if schema is used)

}); // Close describe block
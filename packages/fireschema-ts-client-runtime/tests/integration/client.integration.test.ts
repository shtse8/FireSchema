import { initializeApp, deleteApp, FirebaseApp } from 'firebase/app';
import { getFirestore, connectFirestoreEmulator, terminate, Firestore, doc, getDoc, deleteDoc, collection, getDocs, query, writeBatch, serverTimestamp, Timestamp, DocumentReference } from 'firebase/firestore';
import { ClientBaseCollectionRef, CollectionSchema } from '../../src/baseCollection'; // Import the runtime base class and schema type
import { ClientBaseQueryBuilder } from '../../src/baseQueryBuilder';   // Import Query Builder
import { ClientBaseUpdateBuilder } from '../../src/baseUpdateBuilder'; // Import Update Builder

// --- Test Setup ---
const FIREBASE_PROJECT_ID = 'fireschema-test-emulator';
const FIRESTORE_EMULATOR_HOST = '127.0.0.1';
const FIRESTORE_EMULATOR_PORT = 8080; // Default Firestore emulator port

let app: FirebaseApp;
let firestore: Firestore;

// Simple interface for test data
interface TestData {
  id?: string; // Optional because ID is assigned by Firestore or used for get/delete
  name: string;
  value: number;
  tags?: string[];
  lastUpdated?: Timestamp;
}

// Simple Add type (usually excludes generated fields like id)

// --- Subcollection Types ---
interface SubTestData {
  id?: string;
  description: string;
  count: number;
}
type SubTestAddData = Omit<SubTestData, 'id'>;

// Subcollection class
class TestSubCollection extends ClientBaseCollectionRef<SubTestData, SubTestAddData> {
  constructor(db: Firestore, parentRef: DocumentReference<TestData>) {
    // Subcollections often don't need their own schema definition separate from the parent
    super(db, 'sub-items', undefined, parentRef);
  }
  // Add specific query/update methods if needed
}

type TestAddData = Omit<TestData, 'id'>;

// A concrete class extending the base for testing
// In a real scenario, this would be generated by FireSchema
class TestCollection extends ClientBaseCollectionRef<TestData, TestAddData> {
  constructor(db: Firestore, schema?: CollectionSchema) {
    // No schema provided for this basic test
    super(db, 'test-items', schema);
  }

  // Method to create a query builder instance
  query(): ClientBaseQueryBuilder<TestData> {
    return new ClientBaseQueryBuilder<TestData>(this.firestore, this.ref);
  }

  // Method to create an update builder instance

  // Method to access the subcollection
  subItems(parentId: string): TestSubCollection {
    // Use the protected helper from the base class
    return (this as any)._subCollection(parentId, 'sub-items', TestSubCollection);
  }
  update(id: string): ClientBaseUpdateBuilder<TestData> {
    const docRef = this.doc(id); // Use base class doc() method
    return new ClientBaseUpdateBuilder<TestData>(docRef);
  }
  // Add specific methods if needed, otherwise inherit base methods
}

let testCollection: TestCollection;

beforeAll(async () => {
  // Initialize Firebase App for testing
  app = initializeApp({ projectId: FIREBASE_PROJECT_ID });
  firestore = getFirestore(app);

  // Connect to Firestore Emulator
  connectFirestoreEmulator(firestore, FIRESTORE_EMULATOR_HOST, FIRESTORE_EMULATOR_PORT);

  // Instantiate our test collection class
  testCollection = new TestCollection(firestore);

  console.log(`Connected to Firestore emulator at ${FIRESTORE_EMULATOR_HOST}:${FIRESTORE_EMULATOR_PORT}. Clearing test collection...`);
  // Clear the test collection before all tests
  await clearTestCollection(); // Note: clearTestCollection needs to be defined before this line
  console.log('Test collection cleared.');

  // Clear the test collection before tests (optional, but good practice)
  // Note: A helper function to clear collection might be needed for robustness
  console.log(`Connected to Firestore emulator at ${FIRESTORE_EMULATOR_HOST}:${FIRESTORE_EMULATOR_PORT}`);
});

afterAll(async () => {
  // Terminate Firestore connection
  await terminate(firestore);
  // Delete Firebase App
  await deleteApp(app);
  console.log('Disconnected from Firestore emulator.');
});

// Clear collection before each test run for isolation
// Helper function to clear the collection
async function clearTestCollection() {
    const q = query(testCollection.ref); // Use the collection ref from the instance
    const snapshot = await getDocs(q);
    if (snapshot.empty) {
        return; // Nothing to clear
    }
    const batch = writeBatch(firestore);
    snapshot.docs.forEach(doc => {
        batch.delete(doc.ref);
    });
    await batch.commit();
}

// Clear collection before each test run for isolation
beforeEach(clearTestCollection);


beforeEach(async () => {
    // Basic cleanup: Add a known doc and delete it to ensure connection is ok
    // A more robust cleanup would list and delete all docs.
    try {
        const cleanupDocRef = doc(firestore, testCollection.ref.path, 'cleanup-doc');
        await deleteDoc(cleanupDocRef);
    } catch (error) {
        // Ignore errors if doc doesn't exist
    }
});


describe('Client Runtime Integration Tests', () => {

  it('should add a document and retrieve it', async () => {
    const dataToAdd: TestAddData = { name: 'Integration Test Item', value: 123 };
    let docRef;
    try {
      docRef = await testCollection.add(dataToAdd);
      expect(docRef).toBeDefined();
      expect(docRef.id).toBeTruthy();

      // Retrieve the document directly using the runtime's get method
      const retrievedData = await testCollection.get(docRef.id);

      expect(retrievedData).toBeDefined();
      // ID is not part of the data payload itself in Firestore
      expect(retrievedData).toEqual(expect.objectContaining(dataToAdd));

    } finally {
      // Cleanup: delete the added document
      if (docRef?.id) {
        await testCollection.delete(docRef.id);
      }
    }
  });

  it('should set a document with a specific ID and retrieve it', async () => {
    const docId = 'specific-test-id';
    const dataToSet: TestAddData = { name: 'Specific ID Item', value: 456 };
    try {
      // Use the set method from the base class
      await testCollection.set(docId, dataToSet);

      // Retrieve using the base class get method
      const retrievedData = await testCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData).toEqual(expect.objectContaining(dataToSet));

    } finally {
      // Cleanup
      await testCollection.delete(docId);
    }
  });

   it('should delete a document', async () => {
    const docId = 'to-be-deleted';

  // --- Query Tests --- 

  it('should query documents using where', async () => {
    const id1 = 'query-test-1';
    const id2 = 'query-test-2';
    const data1: TestAddData = { name: 'Query A', value: 100 };
    const data2: TestAddData = { name: 'Query B', value: 200 };
    const data3: TestAddData = { name: 'Query C', value: 100 }; // Same value as data1
    try {
      await testCollection.set(id1, data1);
      await testCollection.set(id2, data2);
      await testCollection.set('query-test-3', data3);

      const queryBuilder = testCollection.query();
      const results = await (queryBuilder as any)._where('value', '==', 100).get();

      expect(results).toHaveLength(2);
      // Check if the results contain the expected names (order might vary)
      const names = results.map(r => r.name);
      expect(names).toContain('Query A');
      expect(names).toContain('Query C');
      expect(names).not.toContain('Query B');

    } finally {
      // Cleanup
      await clearTestCollection();
    }
  });

  it('should query documents using orderBy and limit', async () => {
    const dataSet = [
      { id: 'order-1', data: { name: 'Zebra', value: 1 } },
      { id: 'order-2', data: { name: 'Apple', value: 2 } },
      { id: 'order-3', data: { name: 'Mango', value: 3 } },
    ];
    try {
      // Add test data
      for (const item of dataSet) {
        await testCollection.set(item.id, item.data);
      }

      const queryBuilder = testCollection.query();
      const results = await queryBuilder.orderBy('name', 'asc').limit(2).get();

      expect(results).toHaveLength(2);
      expect(results[0].name).toBe('Apple');
      expect(results[1].name).toBe('Mango');

    } finally {
      // Cleanup
      await clearTestCollection();
    }
  });

  // --- Update Tests --- 

  it('should update a document using the update builder', async () => {
    const docId = 'update-test-1';
    const initialData: TestAddData = { name: 'Initial Name', value: 50 };
    try {
      await testCollection.set(docId, initialData);

      const updateBuilder = testCollection.update(docId);
      const anyBuilder = updateBuilder as any; // Cast once
      await updateBuilder
        ._set('name', 'Updated Name' as any) // Direct set
        .increment('value', 10)      // Increment
        .arrayUnion('tags', ['new', 'updated']) // Array Union
        .serverTimestamp('lastUpdated') // Server Timestamp
        .commit();

      const retrievedData = await testCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData?.name).toBe('Updated Name');
      expect(retrievedData?.value).toBe(60);
      expect(retrievedData?.tags).toEqual(['new', 'updated']);
      expect(retrievedData?.lastUpdated).toBeInstanceOf(Timestamp); // Check type

    } finally {
      // Cleanup
      await testCollection.delete(docId);
    }
  });

  it('should remove array elements and delete fields', async () => {
    const docId = 'update-test-2';
    const initialData: TestAddData = { name: 'Array Remove Test', value: 1, tags: ['a', 'b', 'c'] };
    try {
      await testCollection.set(docId, initialData);

      const updateBuilder = testCollection.update(docId);
      await updateBuilder
        ._arrayRemove('tags', ['b'] as any) // Array Remove
        ._deleteField('value')       // Delete Field
        .commit();

      const retrievedData = await testCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData?.name).toBe('Array Remove Test');
      expect(retrievedData?.tags).toEqual(['a', 'c']);
      expect(retrievedData?.value).toBeUndefined(); // Field should be deleted

    } finally {
      // Cleanup

  // --- Default Value Test --- 


  // --- Subcollection Test --- 

  it('should add, get, and delete documents in a subcollection', async () => {
    const parentId = 'parent-doc-for-sub';
    const subDocId = 'sub-doc-1';
    const parentData: TestAddData = { name: 'Parent Doc', value: 1 };
    const subData: SubTestAddData = { description: 'Sub Item 1', count: 10 };

    try {
      // Create the parent document first
      await testCollection.set(parentId, parentData);

      // Get the subcollection reference
      const subCollection = testCollection.subItems(parentId);
      expect(subCollection).toBeInstanceOf(TestSubCollection);
      expect(subCollection.ref.path).toBe(`${testCollection.ref.path}/${parentId}/sub-items`);

      // Add a document to the subcollection
      const subDocRef = await subCollection.add(subData);
      expect(subDocRef).toBeDefined();
      const addedSubDocId = subDocRef.id;

      // Get the subcollection document using its ID
      let retrievedSubData = await subCollection.get(addedSubDocId);
      expect(retrievedSubData).toBeDefined();
      expect(retrievedSubData).toEqual(expect.objectContaining(subData));

      // Set a document with a specific ID in the subcollection
      await subCollection.set(subDocId, { description: 'Specific Sub Item', count: 20 });
      retrievedSubData = await subCollection.get(subDocId);
      expect(retrievedSubData?.description).toBe('Specific Sub Item');

      // Delete from subcollection
      await subCollection.delete(addedSubDocId);
      retrievedSubData = await subCollection.get(addedSubDocId);
      expect(retrievedSubData).toBeUndefined();

      await subCollection.delete(subDocId);
      retrievedSubData = await subCollection.get(subDocId);
      expect(retrievedSubData).toBeUndefined();

    } finally {
      // Cleanup: Delete parent doc (subcollection is deleted automatically)
      await testCollection.delete(parentId);
    }
  });

  it('should apply serverTimestamp default value from schema', async () => {
    const docId = 'default-value-test';
    const schemaWithDefault: CollectionSchema = {
      fields: {
        lastUpdated: { defaultValue: 'serverTimestamp' },
      },
    };
    // Instantiate a new collection reference WITH the schema
    const collectionWithSchema = new TestCollection(firestore, schemaWithDefault);
    const dataToAdd: TestAddData = { name: 'Default Timestamp', value: 1 }; // lastUpdated is omitted

    try {
      // Add using the collection reference that has the schema
      await collectionWithSchema.set(docId, dataToAdd);

      const retrievedData = await collectionWithSchema.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData?.name).toBe('Default Timestamp');
      expect(retrievedData?.value).toBe(1);
      // Check that the default value was applied
      expect(retrievedData?.lastUpdated).toBeInstanceOf(Timestamp);

    } finally {
      // Cleanup using the same collection reference
      await collectionWithSchema.delete(docId);
    }
  });

      await testCollection.delete(docId);
    }
  });

    const dataToSet: TestAddData = { name: 'Delete Me', value: 789 };
    try {
      await testCollection.set(docId, dataToSet);

      // Verify it exists first
      let retrievedData = await testCollection.get(docId);
      expect(retrievedData).toBeDefined();

      // Delete using the base class method
      await testCollection.delete(docId);

      // Verify it's gone
      retrievedData = await testCollection.get(docId);
      expect(retrievedData).toBeUndefined();

    } catch (error) {
        // Ensure cleanup happens even if assertions fail mid-test
        try { await testCollection.delete(docId); } catch (e) {}
        throw error; // Re-throw the original error
    }
  });

  // Add more tests for:
  // - Updates (requires BaseUpdateBuilder integration)
  // - Queries (requires BaseQueryBuilder integration)
  // - Subcollections (if applicable)
  // - Default values (if schema is used)

});
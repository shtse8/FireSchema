import { initializeApp, deleteApp, FirebaseApp } from 'firebase/app';
import { getFirestore, connectFirestoreEmulator, terminate, Firestore, doc, getDoc, deleteDoc } from 'firebase/firestore';
import { ClientBaseCollectionRef } from '../../src/baseCollection'; // Import the runtime base class

// --- Test Setup ---
const FIREBASE_PROJECT_ID = 'fireschema-test-emulator';
const FIRESTORE_EMULATOR_HOST = '127.0.0.1';
const FIRESTORE_EMULATOR_PORT = 8080; // Default Firestore emulator port

let app: FirebaseApp;
let firestore: Firestore;

// Simple interface for test data
interface TestData {
  id?: string; // Optional because ID is assigned by Firestore or used for get/delete
  name: string;
  value: number;
}

// Simple Add type (usually excludes generated fields like id)
type TestAddData = Omit<TestData, 'id'>;

// A concrete class extending the base for testing
// In a real scenario, this would be generated by FireSchema
class TestCollection extends ClientBaseCollectionRef<TestData, TestAddData> {
  constructor(db: Firestore) {
    // No schema provided for this basic test
    super(db, 'test-items');
  }
  // Add specific methods if needed, otherwise inherit base methods
}

let testCollection: TestCollection;

beforeAll(async () => {
  // Initialize Firebase App for testing
  app = initializeApp({ projectId: FIREBASE_PROJECT_ID });
  firestore = getFirestore(app);

  // Connect to Firestore Emulator
  connectFirestoreEmulator(firestore, FIRESTORE_EMULATOR_HOST, FIRESTORE_EMULATOR_PORT);

  // Instantiate our test collection class
  testCollection = new TestCollection(firestore);

  // Clear the test collection before tests (optional, but good practice)
  // Note: A helper function to clear collection might be needed for robustness
  console.log(`Connected to Firestore emulator at ${FIRESTORE_EMULATOR_HOST}:${FIRESTORE_EMULATOR_PORT}`);
});

afterAll(async () => {
  // Terminate Firestore connection
  await terminate(firestore);
  // Delete Firebase App
  await deleteApp(app);
  console.log('Disconnected from Firestore emulator.');
});

// Clear collection before each test run for isolation
beforeEach(async () => {
    // Basic cleanup: Add a known doc and delete it to ensure connection is ok
    // A more robust cleanup would list and delete all docs.
    try {
        const cleanupDocRef = doc(firestore, testCollection.ref.path, 'cleanup-doc');
        await deleteDoc(cleanupDocRef);
    } catch (error) {
        // Ignore errors if doc doesn't exist
    }
});


describe('Client Runtime Integration Tests', () => {

  it('should add a document and retrieve it', async () => {
    const dataToAdd: TestAddData = { name: 'Integration Test Item', value: 123 };
    let docRef;
    try {
      docRef = await testCollection.add(dataToAdd);
      expect(docRef).toBeDefined();
      expect(docRef.id).toBeTruthy();

      // Retrieve the document directly using the runtime's get method
      const retrievedData = await testCollection.get(docRef.id);

      expect(retrievedData).toBeDefined();
      // ID is not part of the data payload itself in Firestore
      expect(retrievedData).toEqual(expect.objectContaining(dataToAdd));

    } finally {
      // Cleanup: delete the added document
      if (docRef?.id) {
        await testCollection.delete(docRef.id);
      }
    }
  });

  it('should set a document with a specific ID and retrieve it', async () => {
    const docId = 'specific-test-id';
    const dataToSet: TestAddData = { name: 'Specific ID Item', value: 456 };
    try {
      // Use the set method from the base class
      await testCollection.set(docId, dataToSet);

      // Retrieve using the base class get method
      const retrievedData = await testCollection.get(docId);

      expect(retrievedData).toBeDefined();
      expect(retrievedData).toEqual(expect.objectContaining(dataToSet));

    } finally {
      // Cleanup
      await testCollection.delete(docId);
    }
  });

   it('should delete a document', async () => {
    const docId = 'to-be-deleted';
    const dataToSet: TestAddData = { name: 'Delete Me', value: 789 };
    try {
      await testCollection.set(docId, dataToSet);

      // Verify it exists first
      let retrievedData = await testCollection.get(docId);
      expect(retrievedData).toBeDefined();

      // Delete using the base class method
      await testCollection.delete(docId);

      // Verify it's gone
      retrievedData = await testCollection.get(docId);
      expect(retrievedData).toBeUndefined();

    } catch (error) {
        // Ensure cleanup happens even if assertions fail mid-test
        try { await testCollection.delete(docId); } catch (e) {}
        throw error; // Re-throw the original error
    }
  });

  // Add more tests for:
  // - Updates (requires BaseUpdateBuilder integration)
  // - Queries (requires BaseQueryBuilder integration)
  // - Subcollections (if applicable)
  // - Default values (if schema is used)

});